<!DOCTYPE HTML>
<title>Support PUT, PATCH, and DELETE in HTML Forms</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="./proposal.css">

<h1>Support PUT, PATCH, and DELETE in HTML Forms</h1>

<dl>
  <dt>Authors</dt>
  <dd>
    Alexander Petros (<a href="mailto:contact@alexpetros.com">contact@alexpetros.com</a>)<br>
    Carson Gross (<a href="mailto:carson@bigsky.software">carson@bigsky.software</a>)
  </dd>
  <dt>Date Created</dt>
  <dd>August xx, 2024
  <dt>Last Updated</dt>
  <dd>August xx, 2024
  <dt>Status</dt>
  <dd style="color: red;">Unpublished</dd>

</dl>

<details class=toc open>
<summary>Table of Contents</summary>
<noscript>
  The table of contents is generated with JavaScript, which you have disabled.
</noscript>
</details>


<h2>Summary</h2>
<p>
A proposal for adding PUT, PATCH, and DELETE support to HTML forms.

<p>
Proposal 1/3 in the <a href=/triptych>Triptych Proposals</a>.

<h3>Goals</h3>
<p>
PUT, PATCH, and DELETE support in forms should:

<ul>
  <li>be the path of least friction for developing RESTful web services
  <li>integrate seamlessly with existing form semantics
  <li>integrate with existing servers and frameworks that support those methods
  <li>not introduce new security considerations
</ul>

<h2 id=proposed-changes>Proposed Changes</h2>
<p>
New values for the form <code>method</code> attribute:
<ul>
  <li><code>PUT</code> - makes the form issue a PUT request
  <li><code>PATCH</code> - makes the form issue a PATCH request
  <li><code>DELETE</code> - makes the form issue a DELETE request
</ul>

<p>
All new method keywords are case insensitive.
Existing form controls (e.g. <code>action</code>, <code>enctype</code>) should operate identically.

<h2 id=sample-usage>Sample Usage in Resource Lifecycle</h2>

This section demonstrates how PUT and DELETE methods are necessary for managing the lifecycle of a resource.
We use as an example a hypothetical hotel reservation service, in which users have the ability to book hotel rooms.

<p>
All examples in this section assume that the host origin is https://example.com.

<h3 id=basic-create-form>Creating A Resource</h3>

<p>
First, the user makes a reservation using a traditional POST form:<f-note>While PUT is capable of creating new resources, POST is preferred when the service <q><a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-10">selects a proper URI on behalf of the client.</a></q>
This is the simplest RESTful pattern, and has the additional benefit of using a non-idempotent method, so the browser can guard against creating two new things when only one is desired.
More benefits to using this pattern will be discussed in the justifications section.
</f-note>
</p>

<pre class=code>
&lt;form action="/reservations" method="POST"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;input type="date" name="check-in"&gt;
  &lt;input type="date" name="check-out"&gt;
  &lt;input type="checkbox" name="has-pets"&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>

The browser will send the following HTTP request:

<pre class=code>
POST /reservations HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-02&has-pets=on
</pre>

And the server responds with a redirect to the newly-created reservation resource:<f-note>
The <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.4-1">303 SEE OTHER</a> status code is used here because it directs the agent to make the subsequent request as GET, regardless of what method the original request used. 302 FOUND does not do this this, but for historical reasons, browsers <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.3-3.1">typically change POST to GET</a>, while leaving PUT, PATCH, and DELETE methods as is. For this reason, we use 303 for everything.
</f-note>


<pre class=code>
HTTP/1.1 303 SEE OTHER
Location: /reservations/123
</pre>

<h3 id=basic-put-form>Updating A Resource</h3>

<p>
At the reservation page, the user is presented with two forms. The first one allows them to adjust
their reservation:


<pre class=code>
&lt;form action="/reservations/123" method="PUT"&gt;
  &lt;input type="text" name="name" value="Alex Petros"&gt;
  &lt;input type="date" name="check-in" value="2024-12-01"&gt;
  &lt;input type="date" name="check-out" value="2024-12-02"&gt;
  &lt;input type="checkbox" name="has-pets" checked&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>


This new form offers the same controls as the POST form, but with some key differences:<f-note>
The significance of these changes will be discussed more in <section-ref ref=completing-rest>Section 5</section-ref>.
</f-note>


<ul>
  <li>The action has changed from <code>/reservations</code> to <code>/reservations/123</code>
  <li>The method has changed from <code>POST</code> to <code>PUT</code>
  <li>The forms are pre-filled with the values saved at the server.
</ul>

<p>
If the user changes the check-out date to <code>2024-12-03</code>, the browser will send the
following request:


<pre class=code>
PUT /reservations/123 HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-03&has-pets=on
</pre>


The server can then choose to either send back a new page or redirect to one.

<h3 id=basic-delete-form>Deleting A Resource</h3>

The second form on the reservation page allows the user to delete their reservation:<f-note>
In Bugzilla Issue #10671, <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c16">Ian Hickson wrote</a>: <q>PUT as a form method makes no sense, you wouldn't want to PUT a form payload. DELETE only makes sense if there is no payload, so it doesn't make much sense with forms either.</q>.
<br>
While we disagree with this comment for the many of the same reasons that <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c18">Cameron Jones</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c21">Tom Wardrop</a> did originally, there is one limited sense in which Hickson's comment is correct: it doesn't make much sense to wrap a button in a form tag to issue a payload-less DELETE request.
We address this limitation in <a href="#">Triptych Proposal #2: Button HTTP Requests</a>.
</f-note>


<pre class=code>
&lt;form action="/reservations/123" method="DELETE"&gt;
  &lt;button&gt;Delete Reservation&lt;/button&gt;
&lt;/form&gt;
</pre>


Clicking "Delete Reservation" would result in the following HTTP request:


<pre class=code>
DELETE /reservations/123 HTTP/1.1
Host: example.com
</pre>


And the server could choose to either send a delete confirmation page, or redirect elsewhere.


<h2>Additional Considerations</h2>

<h3 id=body-content>Body Content</h3>

<p>
PUT and PATCH forms should send identical content to their POST equivalents.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#appendix-B.3-5">"Content" was previously known
  as "payload"</a> or "payload body", and is set using the <code>body</code> property of a fetch
request.
</f-note>

<f-note>
All three methods support the same Content-Type headers, and they are differentiated from each
other based on the intent for the enclosed representation, not the representation itself.
Per <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-put">RFC9110</a>, the difference
between POST and PUT <q>is highlighted by the different intent for the enclosed representation,</q>
which implies that they support the same set of representations. Per
<a href="https://www.rfc-editor.org/rfc/rfc5789">RF5789</a>, which defines PATCH, <q>the
difference between the PUT and PATCH requests is reflected in the way the server processes the
enclosed entity to modify the resource</q>, which again implies that they are capable of
representing resources the same way.
</f-note>
Server frameworks that support PUT and PATCH handle their bodies identically to POST bodies;
the vast majority of servers will support the new feature out of the gate.<f-note>
For examples, see <section-ref ref="rest-server-support">Section 6.3</section-ref>
</f-note>

<p>
DELETE forms should format their content as URL parameters, like GET forms. While both GET and
DELETE body semantics are technically undefined, including content in the request body is somewhat
discouraged by the spec.<f-note>
While <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-delete">RFC9110</a> states that a
<q>DELETE request has no generally defined semantics,</q> it also states that <q>a client SHOULD NOT
generate content in a DELETE request unless it is made directly to an origin server that has
previously indicated, in or out of band, that such a request has a purpose and will be adequately
supported</q>. While one could certainly argue that the server returning HTML with <code>&lt;form
  method=DELETE&gt;</code> constitutes indication of support for content, we defer to the library
ecosystem, which generally understands the similar language in the GET and DELETE specs as a tacit
discouragement of body content for both.
</f-note>
Therefore, forms with <code>method=DELETE</code> should encode their inputs as part the URI,
emulating the behavior of forms with no <code>method</code>, or <code>method=GET</code>.<f-note>
While many server frameworks are agnostic to the relationship between HTTP methods and the body of the HTTP request, one notable exception is the golang standard library's <a href="https://pkg.go.dev/net/http#Request.ParseForm">ParseForm</a> function, which reads POST, PUT, and PATCH requests as urlencoded forms, but ignores the body if the request has any other method.
</f-note>

<h3>Caching</h3>
<p>
PUT, PATCH, and DELETE requests are <a href="https://httpwg.org/specs/rfc9110.html#safe.methods">
unsafe</a> (not read-only), and therefore can never be cached.

<p>
PATCH <em>responses</em> are technically cacheable in the same way that POST responses are: if
certain information is explicitly provided, subsequent GET requests may use the cached PATCH
response to represent that resource.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc5789#section-2">RFC 5789 Section 2</a>,
</f-note> Browsers that implement this behavior for POST requests should do so for PATCH requests,
although the spec notes that the overwhelming majority of cache implementations do not.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.3-2">RFC 9110 Section 9.2.3</a>,

<p>
PUT and DELETE responses are never cacheable.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-13">RFC 9110 Section 9.3.4</a>,
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.5-7">Section 9.3.5</a>
</f-note>



<h3 id=cors>CORS</h3>

<p>
In the interest of limiting the scope of the proposal, browsers should, to start, only support PUT, PATCH, and DELETE forms that are making same-origin requests.

<h4>Background</h4>

<p>
A cross-origin request is when a webpage at one origin (typically, this means a domain) attempts to request a resource from a different origin.
Modern browsers block most cross-origin requests by default, as a security feature.
Among other benefits, blocking cross-origin requests significantly mitigates the attack surface for malicious websites to take unwanted actions against other servers on the user's behalf—in particular via Cross-Site Request Forgery (CSRF).

<p>
There are, however, instances in which servers want to explicitly opt-in to cross-origin requests.
Cross-Origin Resource Sharing (CORS) is a header-based mechanism that allows them to do so.
When a website makes a request to a server with a different origin than its own, the browser will, in most cases, send a "preflight request" to ask that server to what extent it permits loading its resources on other pages.

<p>
HTML forms predate CORS, so CORS contains a number of exceptions to the same-origin policy, designed to keep from breaking existing web forms while still moving web security forward.
The browser will not send a preflight request to cross-origin servers (it'll just make the request directly) if the request falls within certain confines—essentially the confines of what HTML forms were capable of prior to the specification of CORS.<f-note>
The <a href="https://fetch.spec.whatwg.org/#general">fetch spec</a> actually goes a bit further and says: <q>for requests that are more involved than what is possible with HTML's form element, a CORS-preflight request is performed, to ensure request’s current URL supports the CORS protocol.</q>
This part would have to be amended slightly to unpeg CORS from what forms are capable of, since we advocate for extending form capabilities without adding to the <a href="https://fetch.spec.whatwg.org/#cors-safelisted-method">CORS-safelisted methods</a> or <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">CORS-safelisted request headers</a>.
</f-note>

<p>
Therefore, expanding the scope of what is possible through the HTML form element also requires reckoning with how that impacts the scope of what is possible without a CORS pre-flight request.

<!-- GET, HEAD, and POST requests that -->

<h4>Recommendation</h4>

<p>
The browser should disallow cross-origin PUT, PATCH, and DELETE forms, logging the error to the console.
This minimizes implementation complexity as much as possible while still meeting the proposal's goals of incentivizing same-origin RESTful application development by making it the simplest way to build an interactive web service.

<!-- <p> -->
<!-- The motivation for including PUT, PATCH, and DELETE support in HTML forms is to make safe, secure, same-origin RESTful application development as easy as possible. -->

<!-- Explicitly omitting CORS support from this proposal reduces the implementation complexity for browser vendors, solves the majority use-case, and leaves the door open for CORS support later, vendor interest permitting. -->

<p>
First and foremost, new browser features must not expose existing servers or users to new vulnerabilities, so adding new CORS-safelisted methods or headers is out of the question.<f-note>
<a href="https://github.com/whatwg/html/issues/3577#issuecomment-625880214">@annevk on issue #3577</a> <q>the same-origin policy cannot be extended further as that would put servers at risk.</q>
</f-note>
Fortunately, there is no need to do so.

<p>
PUT, PATCH, and DELETE forms simply make available to HTML a highly useful subset of what is <em>already available</em> to the web page, via JavaScript.
JavaScript is capable of making single-origin and cross-origin PUT requests; we propose that HTML be capable of making single-origin requests, which does not extend the median browsers' capabilities at all.<f-note>
The word "median" is used here to acknowledge that, technically, this does make new HTTP methods available to browsers which have scripting disabled.
The overwhelming majority of browser users, especially the ones most vulnerable to malicious websites, do not having scripting disabled, and the methods we propose adding are more secure than the POST method that is already available.
</f-note>

<p>
Moreover, the addition of CORS-restricted methods to HTML forms provides a massive opportunity to move developers onto a more secure pattern web applications.
PUT, PATCH, and DELETE requests are more secure, by default, than POST requests, because they will <em>never</em> be issued to a cross-origin server unless that server explicitly permits them.<f-note>
This is another, highly significant, reason not to tunnel PUT and DELETE through POST requests with ad-hoc semantics, one that did not exist when Amundsen et. al were arguing for PUT and DELETE support in
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c4">WHATWG Bug 10671</a>.
</f-note>
Because POST is the only unsafe method currently available to HTML forms, the introduction of PUT and DELETE necessarily displaces usage of POST methods, reducing the number of webforms that are vulnerable to CSRF due to backwards compatibility concerns.<f-note>
It also opens the door for the possibility of introducing a new method (i.e. CREATE) that serves a similar purpose to POST but is unburdened by the same backwards compatibility concerns.
POST could continue to serve as a <a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post"><q>this action isn't worth standardizing</q></a> method, and work for legacy applications.
</f-note>

<!-- <a href="https://github.com/httpwg/http-extensions/issues/2228">@annevk on issue #2228</a> <q>changes to form submission will be hard. And almost definitely any new kind of cross-origin method would require some kind of opt-in as the safety we care about is not that of the method definition of safety, but that of end users.</q> -->


<!-- Giving developers access to them in HTML dramatically reduces the difficulty of taking advantage of these more-secure methods. -->

<p>
In this manner, CORS restrictions can be leveraged to deepen the web security pit of success.
Sites that make no cross-origin requests are easier to secure than sites that do.<f-note>
CORS and the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value">SameSite Attribute</a> dramatically reduce the opportunity for attackers to execute cross-site requests.
</f-note>
Sites that use REST verbs properly are easier to secure than sites that don't.<f-note>
The <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSRF">MDN Page for CSRF</a> ends with this note: <q>There are many ways to prevent CSRF, such as implementing [sic] RESTful API, adding secure tokens, etc.</q>
Unfortunately, it doesn't describe how a RESTful API might mitigate CSRF.
What they likely mean by this is that ensuring GET requests do not have side effects mitigates a number of CSRF pathways, but it's also true that HTML does not does not properly support RESTful APIs, nor does it currently have the ability to make any unsafe HTTP requests that are fully protected by CORS.
For more on the importance of supporting REST and the ways in which HTML support is inadequate, see <section-ref ref=completing-rest>Section 5</section-ref>.
</f-note>
Web forms that make using REST verbs trivial for same-site requests—especially REST verbs that are not safelisted by CORS—incentivize the simplest, most secure patterns by also making them the easiest to implement.

<!-- <f-note> -->
<!-- CORS is a mechanism for lifting the browser's security guarantees; rather than lift them, developers should be provided a path of least resistance to comply with them. -->
<!-- </f-note> -->

<h3>Navigation</h3>
<h4>Rendering</h4>
If the response status code is not a redirection code (300-399), the browser should display the body
of the response in the page, exactly the same way it would for the response of a POST form.
It should likewise update the page URL and history.

<h4>Redirection</h4>
<p>
For PUT, PATCH, and DELETE requests, if the server responds with a 301, 302, or 307 status code, the browser should perform a subsequent request with the same HTTP method;
if the server responds with a 303 status code, the browser should perform a subsequent request with the GET method.<f-note>
When browsers receive a 302 response to a POST form, they typically follow that redirect
automatically and change the method to GET;
there is no need for this behavior to apply to PUT, PATCH, and DELETE.
Changing POST to GET in this fashion is a backwards compatibility carveout in the spec, which has not been applied to other methods in browsers' fetch implementations.
Using a 303 to perform POST-redirect-GET flow (replacing POST with PUT or DELETE) is already a well-understood pattern for server frameworks that support these methods, so no additional carveouts are needed to integrate with them.

For instance, <a
  href="https://stackoverflow.com/questions/33214717/why-post-redirects-to-get-and-put-redirects-to-put">ExpressJS</a>
and <a href="https://stackoverflow.com/questions/71975005/rails-not-redirecting-on-put-request-sending-406-back-instead">Rails</a>.
</f-note>

<p>
The browser should only follow redirects to servers of the same origin.<f-note>
For more on potential future CORS support, see <section-ref ref=alternative-cors-support>Section 8.2</section-ref>
</f-note>
If the server responds to any of the new methods with a redirect to a server of a different origin, the browser should display an error indicating that the server tried to redirect the page in a manner that is unsupported at this time.<f-note>
The navigation flow we propose here is one in which the browser "quietly" fails to execute an explicit cross-origin request (simply logging to the console and taking no further action), but "loudly" fails to execute a cross-origin redirect, in a similar manner to how the browser will display a full-screen error for an infinite redirect or an expired TLS certificate.

<br><br>
This is a compromise between the way the browser handles JavaScript-based CORS failures (quietly) and how the browser generally handles navigation failures (loudly). Other options are available depending on the recommendations on editors and implementers.
</f-note>


<p>
This resolves a blocker for the original Firefox beta implementation.<f-note>
On 01/12/2011, at 9:57 PM,
<a href="https://lists.w3.org/Archives/Public/public-html-comments/2011Apr/0000.html">
Julian Reschke wrote:</a>
<q>One thing I forgot earlier, and which was the reason why I actually wanted PUT and DELETE
temporarily (!) on hold is redirect handling. The experimental Firefox implementation was copying
the redirect handling for POST (with respect to method rewriting), and it would have been bad to let this get into the deployed platform.
The experimental Firefox implementation was copying the redirect.
So it would be good to clarify that PUT and DELETE, when being redirected by 301/302 should *not* be rewritten to GET.</q>
</f-note>

<h4>Refresh Button</h4>
<p>
For PATCH requests, which are not idempotent, the user agent should behave as it does currently, asking the user for confirmation and warning that it may cause the data to be re-submitted.

<p>
For PUT and DELETE requests, which are idempotent, the user agent should resubmit the request.
This allows servers to take advantage of the method semantics and create forms that users on unreliable connections can feel confident re-submitting.

<h2 id=completing-rest>Completing REST</h2>
In 2000, Roy Fielding published a PhD dissertation in which he introduced the Representational State
Transfer (REST) architectural style for distributed hypermedia systems.
While these principles were used to guide the early development of the World Wide Web, they are
often badly misunderstood.<f-note>
Carson Gross notes in <a href="https://htmx.org/essays/hateoas/"><cite class=article>HATEOAS — An Alternative Explanation</cite></a> that the <a href="https://en.wikipedia.org/wiki/HATEOAS">Wikipedia Entry for "Hypertext as the engine of application state"</a>, one REST's fundamental constraints, uses a JSON API as an example, even though JSON is not hypertext.
Roy Fielding is less polite: in <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven"><cite class=article>REST APIs must be hypertext-driven</cite></a>, he complains that a different "REST" API, which also did not user hypertext, has <q>so much coupling on display that it should be given an X rating.</q>
</f-note>

<p>
Despite the misconceptions, REST remains the most powerful conceptual tool for building durable
hypermedia applications.
In this section, we make the case for how better method support in HTML can drive adoption of REST
priciples and dramatically improve the median web application as a result.

<!-- This explanation draws on his references to it in his , and Carson Gross' <a href="https://htmx.org/essays/hateoas/">"alternative -->
<!-- explanation"</a> of the term. -->
<h3>REST in Theory</h3>

<p>
In the dissertation that defines REST, Roy Fielding includes HTTP methods among the core interface
constraints of REST—specifically the constraint that messages need to be self-describing.<f-note>
<a href="https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">Section
  5.1.5:</a> <q>REST enables intermediate processing by constraining messages to be self-descriptive:
interaction is stateless between requests, standard methods and media types are used to indicate
semantics and exchange information, and responses explicitly indicate cacheability.</q>
</f-note>
He does not, however, address which methods are necessary.<f-note>
<a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post">Fielding, in 2009:</a> <q>Search my dissertation and you won't find any mention of CRUD or POST.
The only mention of PUT is in regard to HTTP's lack of write-back caching.
The main reason for my lack of specificity is because the methods defined by HTTP are part of the Web's architecture definition, not the REST architectural style.</q>
</f-note>
His main concern is that the name of the method should not affect the parsing of the HTTP request, as
that would require out-of-band agreement on method semantics and limit the extensibility of the
method field.<f-note>
<a href="https://ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_3_1_2">
  Section 6.3.1.2
</a>
</f-note>

<p>
Fielding actually appears to be somewhat ambivalent about whether the user agent should have
<em>any</em> understanding of method semantics. In 2008, he writes:

<blockquote>
<q>You don't get to decide what POST means — that is decided by the resource. Its purpose is
supposed to be described in the same context in which you found the URI that you are posting to.</q><f-note>
<a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-732">"REST APIs must be hypertext-driven", Comment #13</a>
</f-note>
</blockquote>

That GET, POST, and PUT have semantic meaning outside the context of the application is a secondary concern;
the primary obligation of the client is to allow the hypermedia API to describe itself, and then faithfully execute that description.<f-note>
Fielding's comments on method usage are somewhat contradictory.
In <cite class=article><a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post">It is okay to use POST</a></cite>, he seems broadly committed to the principle that the server gets to define what the methods mean, reminding readers that specific <q>method definitions (aside from the retrieval:resource duality of GET) simply don't matter to the REST architectural style</q>.
He also asks: <q>why shouldn't you use POST to perform an update? Hypertext can tell the client which method to use when the action being taken is unsafe.</q>

<br><br>

But in the next paragraph, he says that POST is an issue <q>when it is used in a situation some other method is ideally suited,</q> including <q>complete replacement of a representation (PUT)</q>.
So it's fine to use POST to update a resource, unless your update is a complete representation of that resource, in which case it's not?
Is it fine to use POST method to delete a resource, a task for which DELETE is ideally suited?

<br><br>
The most reasonable way to interpret Fielding's statements here (and the statements referenced in the following footnote) is that REST is primarily concerned with defending the distributed system's ability to write self-describing messages, but deliberately unconcerned with what those messages mean, as long as they do not violate any of the already-established out-of-band agreements enshrined within the protocols themselves.
This allows for some necessary compromises to the theoretical purity of self-description—like the user agent being able build security features around the knowledge that GET requests are safe—while still allowing for method extension and graceful fallback.
</f-note>

The HTML form element's transformation of any non-GET, non-POST method into a GET violates this principle.<f-note>
n.b. Fielding's <a
href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">"REST APIs must be
hypertext-driven" blog</a> does include the follow bullet:
<q>A REST API should not contain any changes to the communication protocols aside from filling-out
or fixing the details of underspecified bits of standard protocols, such as HTTP's PATCH method or
Link header field. Workarounds for broken implementations (such as those browsers stupid enough to
believe that HTML defines HTTP's method set) should be defined separately, or at least in
appendices, with an expectation that the workaround will eventually be obsolete.</q>
Exactly what he means by <q>browsers stupid enough to believe that HTML defines HTTP's method set</q> is a little vague, but it clearly demonstrates frustration with HTML's limited method support.
</f-note>

<p>
We do not propose that HTML execute arbitrary HTTP methods specified in the form's method attribute, although that would fit nicely within the REST guidelines by allowing web APIs to freely self-describe across an already-available dimension.<f-note>
This is neverthless an intriguing idea.
If HTML allowed the use of arbitrary HTTP methods, developers could pilot new client networking semantics in a backwards-compatible fashion.
Of course, the implications of this are wide-ranging and far exceed the scope of this proposal.
</f-note>
Instead, we simply urge that HTML support the relevant, existing HTTP methods, which are so useful that they are universally-supported by servers in spite of their absence from the HTML standard.

<!-- https://ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_3_1_2 -->

<!-- <p> -->
<!-- By presenting the user with both the current application state (the form values) and possible -->
<!-- actions on that state (the input types and submit button), HTML is able to fulfill its duty as a -->
<!-- uniform interface. -->


<h3>REST in Practice</h3>

<p>
HTTP methods have become more central to the developer community's conception of REST than
Fielding perhaps intended, and are one of its better-understood concepts.
In Jeremy Richardson's <a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Maturity Heuristic</a>, later dubbed the
<a href="https://martinfowler.com/articles/richardsonMaturityModel.html">"Richardson Maturity
  Model"</a> by Martin Fowler, proper use of HTTP methods is one of the three levels that determine
how well an application adheres to REST principles.<f-note>
Both of these explicitly sidestep the "controversy" about whether PUT and DELETE
should be supported by HTML. Fowler notes that in the absence of PUT and DELETE support in HTML,
what we essentially have in HTTP is GET and POST standing in for safe and unsafe requests,
respectively.
</f-note>

<ol start=0>
  <li>Using HTTP
  <li>Using resource URIs
  <li>Using HTTP verbs (methods)
  <li>Responding with hypermedia
</ol>

<p>
The increased salience of HTTP methods to REST is not a perversion of the concept, but a practical evolution of it, born from real-world use.
Aspirational REST adherents have discovered that it is much easier to uphold a consistent representation of a resource (via URIs) when you have a standardized semantic for to describe <em>how</em> the enclosed resource is to be modified.

<p>
For instance, this overview is from the first API tutorial in the latest ASP.NET Core documentation:<f-note>
<a
  href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&tabs=visual-studio">Tutorial:
  Create a web API with ASP.NET Core</a>; interestingly, this tutorial doesn't even mention REST,
although it does link to another page describing RESTful APIs.
</f-note>

<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
<th>Request body</th>
<th>Response body</th>
</tr>
</thead>

<tr>
<td><code>GET /api/todoitems</code></td>
<td>Get all to-do items</td>
<td>None</td>
<td>Array of to-do items</td>
</tr>
<tr>
<td><code>GET /api/todoitems/{id}</code></td>
<td>Get an item by ID</td>
<td>None</td>
<td>To-do item</td>
</tr>
<tr>
<td><code>POST /api/todoitems</code></td>
<td>Add a new item</td>
<td>To-do item</td>
<td>To-do item</td>
</tr>
<tr>
<td><code>PUT /api/todoitems/{id}</code></td>
<td>Update an existing item &nbsp;</td>
<td>To-do item</td>
<td>None</td>
</tr>
<tr>
<td><code>DELETE /api/todoitems/{id}</code> &nbsp; &nbsp;</td>
<td>Delete an item &nbsp; &nbsp;</td>
<td>None</td>
<td>None</td>
</tr>

</table>

<p>
This how most developers understand REST: a service is RESTful if it uses methods and URIs to describe what <strong>action</strong> you're taking on what <strong>resource</strong>.
But if you look closely, you'll notice that it's not REST: the API returns JSON data, not hypermedia. The popular conception of REST is stuck at Level 2 of the Richardson Maturity Model.

<p>
Developers choose to build APIs with the standardized method grammar—in spite of missing HTML support—because it's simpler.
An API that supports <code>PUT /users/123</code> and <code>DELETE /users/123</code> is easier to
describe and code than a <code>POST /users/123</code> API whose body semantics alter how it processes the enclosed resource.

<p>
The usefulness of methods as an HTTP semantic—<i>a priori</i> to the semantics of the methods
themselves—is so self-evident that the hypertext transfer protocol has long standardized a bunch of
additional methods; all that remains is for the dominant hypertext markup to support them.<f-note>
The purpose of describing REST in this detail, and the "REST in Practice" subsection in particular,
is to make clear that REST is not an ivory tower architecture that developers have failed to follow; it's an attempt to explain the best real-world developer practices and model the ways in which user agents can support them. The lack of proper method support is a <a href="https://www.w3.org/TR/html-design-principles/#solve-real-problems">real problem</a> that developers continually work around. For evidence of this, see <section-ref ref=ecosystem-demand>Section 6: Ecosystem Demand</section-ref>.
</f-note>

<h3>The Limits of Scripting</h3>

<p>
REST is an enduring paradigm that suites a wide variety of web applications, and developers today have a number of good libraries to choose from if they wish to implement it.
But even a client-loaded library with the perfect interface can never replace the functionality or durability of an official implementation.

<p>
Most libraries that implement REST primitives use them with partial page replacement.
This is largely due to demand in the developer ecosystem for partial page replacement, but it masks an important limitation: JavaScript cannot modify browser navigation primitives.<f-note>
To be clear, this is a very reasonable limitation—JavaScript probably <em>shouldn't</em> be able to do that.
That's why this will require expanding the <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#beginning-navigation">navigation spec</a> to include resources for additional methods.
</f-note>
A form that makes POST request "navigates" to that URL, displaying the results on the page and resetting the JavaScript environment; no JavaScript-based implementation of the PUT method can perform the same task.<f-note>This is the biggest weakness of the <a href="https://github.com/alexpetros/triptych">Triptych Polyfill</a>, that it cannot make PUT form requests that navigate to an entirely new page, therefore cannot properly implement POST-redirect-GET (with PUT instead of POST).
It cannot even intercept 303 redirects and manually navigate to them, because the location header is not available in fetch's manual redirect mode.
</f-note>
While partial page replacement is useful for highly interactive applications, full page navigation is a much more accessible and secure paradigm.<f-note>
Among the <a href="https://unplannedobsolescence.com/blog/hard-page-load/">many reasons for this</a> are that end-users can use browser controls to manage "hard" navigations—and browsers can optimize around that behavior without any addition effort from users or page authors.
</f-note>


<!-- <f-note> -->
<!-- While an old directory of HTML files will almost certainly be easier to deploy than an old NodeJS project, many "dynamic" architectures are closer to the former than the latter. -->
<!-- For instance, vanilla PHP can be written and deployed in almost exactly the same manner as HTML files. -->
<!-- See also: <a href="https://blog.wesleyac.com/posts/no-static-websites"><cite class=article><a href="https://blog.wesleyac.com/posts/no-static-websites">There is no such thing as a static website</cite></a>There is no such thing as a static website</a> -->
<!-- </f-note> -->

<p>
Given HTML's tremendous backwards- and forwards-compatibility guarantees, its capabilities guide the design of durable interactive applications.
For instance, the vast majority of Wikipedia's functionality can be described with hypertext primitives—including its relatively limited interactivity.<f-note>
Wikipedia obviously supports enormous traffic, but the type of interactivity is mostly limited to creating and updating hypertext pages, as well as managing a user account, neither of which push the limits of what an HTML form can currently describe.
The addition of <code>method=DELETE</code> might be helpful for something like deleting a comment on a user talk page, but by and large, Wikipedia's core functionality does not involve a lot of deleting things, so the compromises involved with representing the deletions it does has are minimal.
</f-note>
Not only can you browse Wikipedia with JavaScript disabled, you can create an account and edit pages too;
with scripting enabled, editing is augmented by a rich-text editor, but in most other respects the experience is close to identical.

<p>
Many applications that thrive on the web have ore complicated resource lifecycles than Wikipedia, like banking, travel bookings, and social media.
The new lifecycle methods would make it possible for those applications to built their interactivity in a hypertext-driven style, and take full advantage of the browser's reliability, security, and longevity as an application platform.

<!-- The web is already one of, if not the most the essential telecommunications platform of the 21st century. -->
<!-- Making HTML the easiest, cheapest, and most dependable base for building distributed systems -->
<!-- would cement the web as the dominant infrastructure platform for essential services, where -->
<!-- reliability and accessibility are prized above all else. -->




<!-- <p> -->
<!-- Scripting is a great way to augment the web platform, but it is a bad basis for durable applications. -->
<!-- Many once-widespread browser extensions, like Java Applets and Adobe Flash, are no longer supported at all.<f-note> -->
<!-- Java Applets were <a href="https://openjdk.org/jeps/289">deprecated in 2017</a>. -->
<!-- Adobe Flash, once a dominant method for creating and distributing interactive web media, was blocked from transitioning to the mobile web, discontinued in 2017. -->
<!-- Microsoft Silverlight, which powered the early days of Netflix's web streaming platform, was discontinued in 2021. -->
<!-- <br><br> -->
<!-- While all these code-on-demand extensions helped push the web platform forward, much of their functionality was eventually adopted into the standard, and web content from organizations that didn't have the resources to migrate it is now very hard to access. -->
<!-- The breadth and <a href="https://edition.cnn.com/2021/09/10/tech/digital-news-coverage-9-11/">historical significance</a> of Flash-based web content, in particular, has spurred heroic efforts to preserve them, including the open-source flash emulator, <a href="https://ruffle.rs/">ruffle</a>, which is available for all major browsers. -->
<!-- </f-note> -->
<!-- JavaScript is a permanent part of the web platform, but today many JS-based websites are "built" with compilers and non-standard file formats—maintaining these requires constant updates to the build stack.<f-note> -->
<!-- If the compiler updates in a way that breaks your build, you can continue to run an old version of the compiler, but the feature set that your application has to work with freezes. -->
<!-- Either the maintainers have to commit to a potentially costly refactor, or continue to maintain their application with an increasingly out-of-date architecture. -->
<!-- This is never happens to HTML-forward applications, which can always take advantage of additions  to HTML's living standard without being forced to migrate old code. See also: <a href="https://htmx.org/essays/no-build-step/"><cite class=article>Why htmx Does Not Have a Build Step</cite></a>. -->
<!-- </f-note> -->
<!-- Even websites that load JS directly into the browser run the risk that their website's functionality is too intricately tied to the framework chosen, and they'll be stuck with a lot of code written around an interface that is no longer actively supported. -->

<!-- <p> -->
<!-- Meanwhile, HTML has possibly the strictest backwards and forwards compatibility guarantees in software. -->
<!-- HTML documents from the earliest days of the web run perfectly on the web browsers in your smartphone.<f-note> -->
<!-- This includes everything from a <a href="https://first-website.web.cern.ch/first-website/node/24.html">1991 hypertext demo</a>, <a href="http://info.cern.ch/hypertext/WWW/TheProject.html">the very first web page</a>, and The Washington Post's <a href="https://www.washingtonpost.com/wp-srv/inatl/longterm/diana/dianastories.htm">special edition home page commemorating Princess Diana.</a> -->
<!-- Very little 20<sup>th</sup> century software can be run that easily on modern devices. -->
<!-- </f-note> -->
<!-- People who author an HTML file today can feel more confident that it will be faithfully rendered and easy to read as long as browser remain relevant. -->

<!-- because REST is software design on the scale of decades.<f-note> -->
<!-- From <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-724">"Rest APIs Must be Hypertext Driven," Comment #8</a>: -->
<!-- <q>REST is software design on the scale of decades: every detail is intended to promote software longevity and independent evolution. -->
<!-- Many of the constraints are directly opposed to short-term efficiency. [...] -->
<!-- There are more than a few software methodologies that portray any long-term thinking as wrong-headed, ivory tower design (which it can be if it isn't motivated by real requirements).</q> -->
<!-- </f-note> -->


<!-- Authors for whom proper REST support is a priority will not have to automatically resort to scripting, and authors who have no conception of REST, but are starting with HTML as the easiest way to build a client, will be guided towards REST by ease of use.<f-note> -->
<!-- Consider the cliched "to-do app" that is often the goal of beginner web tutorials. -->
<!-- After implementing and experimenting with note creation, a beginner developer will ask themselves <q>well, how do I delete these?</q> -->
<!-- The simplest, lowest-effort path to a delete button is going to be re-using the same route, but with a DELETE method—and all that has to be done on the client is add a new form with the same <code>action</code> and a new <code>method</code>. -->
<!-- </f-note> -->
<!-- In both cases, the benefit of being RESTful isn't that that it confirms to abstract theoretical purity—it's using a set of technologies that are built to last. -->

<!-- <p> -->
<!-- We argue that HTML's inability to express RESTful application patterns is preventing developers from taking advantage of the web platform's marquee feature: its longevity. -->

<!-- <p> -->
<!-- Finally, broadening the available form methods not only simplifies the client—it makes it possible to describe the "backend" of the application in a way that makes the server more fungible as well. -->
<!-- A wide variety of languages and server frameworks have support for declaring routes and methods; the task of switching between them, if such becomes necessary, becomes easier the more the application can be described at that high level of abstraction. -->

<!-- <p> -->
<!-- In 2008, Fielding writes: -->

<!-- <blockquote> -->
<!-- Many of the constraints are directly opposed to short-term efficiency. [...] -->
<!-- There are more than a few software methodologies that portray any long-term thinking as wrong-headed, ivory tower design (which it can be if it isn't motivated by real requirements).<f-note> -->
<!-- <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-724">"Rest APIs Must be Hypertext Driven," Comment #8</a> -->
<!-- </f-note> -->
<!-- </blockquote> -->

<!-- <p> -->
<!-- With decades of practice, we have access to information that Fielding did not when he was describing the nascent web, namely, that the longevity of a service is directly correlated with the degree to which is able to represent itself without augmenting the hypertext; on the web, a service whose functionality can be built with mostly HTML is likely to last longer than one that relies more on JavaScript. -->

<!-- <p> -->
<!-- Included in the REST architectural style is the "optional constraint" of code-on-demand: client functionality can be extended by downloading and executing code in the form of applets or scripts. -->
<!-- As an example, Fielding describes an organization that wants to run Java Applets from internal sources, but disables untrusted, external Applets.<f-note> -->
<!-- https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_7 -->
<!-- </f-note> -->

<!-- <f-note> -->
<!-- Although hypermedia representations are a core tenet of REST, relatively little is said in the thesis about the necessary qualities of that hypermedia representation. Chapter 6 contains sections on <a href="https://ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_2">"Rest Applied to URI"</a> and <a href="https://ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_3">"REST Applied to HTTP"</a> but not "REST Applied to HTML." -->
<!-- </f-note> -->

<!-- <p> -->
<!-- If REST is so cumbersome to implement in HTML, what if the fault lies not with HTML, but with REST. -->
<!-- Perhaps REST served as a useful guideline for the early days of the web, but is no longer up to the demands of modern web applications? -->
<!-- This is not so. -->

<!-- One of these software systems is the World Wide Web itself, which REST was designed to describe and direct. Despite fierce competition from desktop and mobile applications, the web remains arguably the dominant platform for application development today. But -->

<h2 id=ecosystem-demand>Ecosystem Demand</h2>

Lacking proper browser support, developers still consider method semantics important enough to their
API design that they come up with ad-hoc methods to achieve the same result.

<h3>The Hidden Input Hack</h3>

<p>
The most common way that developers compensate for the lack of proper HTTP method support is to
include a hidden input that overrides the method.
<f-note>
For instance, <a href="https://unpoly.com/up.protocol.config#config.methodParam">unpoly</a> can automatically convert PUT forms into POST forms with an <code>&lt;input name=_method value=PUT&gt;</code> input.
</f-note>

<pre class="code">
&lt;form method="post" action="/users/123"...&gt;
  &lt;input type="hidden" name="_method" value="put"&gt;
  ...
&lt;/form&gt;

&lt;form method="post" action="/users/123"...&gt;
  &lt;input type="hidden" name="_method" value="delete"&gt;
  ...
&lt;/form&gt;
</pre>


<p>
This would be a Level 1 on the Richardson Maturity Model. The URIs consistently identify a
resource (<code>user/123</code>), but the method is always POST, so the verbs aren't in use.

<p>
This pattern has a number of drawbacks that would be rectified by proper PUT, PATCH, and DELETE
support:<f-note>
These points are not new; many of them were made by Mike Amundsen in the closed
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c4">WHATWG Bug 10671</a>.
</f-note>

<ul>
  <li>Unlike POST, PUT and DELETE are idempotent, which gives the user agent more leeway to recover from network failures
  <li>HTTP methods are typically logged while HTTP bodies are not; services that break up their unsafe requests across POST, PUT, and DELETE have a smaller surface to debug than ones where all unsafe request are tunneled through POST.
  <li>HTTP methods are a powerful filtering tool for debugging across the stack—server logs, application logs, and the browser network tab.
  <li>Routing is fundamental to server logic, and including an additional variable for routing dramatically simplifies the server logic that would otherwise have to compensate by performing additional routing imperatively.
  <li>PUT and DELETE do not have the same CORS exemptions that POST does, making them more secure for user agent (discussed in <section-ref ref=cors>Section 4.3</section-ref>)
</ul>

<h3>Ad-hoc URI Semantics</h3>

<p>
Another workaround is to encode the method semantics straight into the URI.
</p>

<pre class="code">
&lt;form method="post" action="/users/123/put"...&gt;
  ...
&lt;/form&gt;

&lt;form method="post" action="/users/123/delete"...&gt;
  ...
&lt;/form&gt;
</pre>



<p>
This actually resolves some of the operational issues with the hidden input hack. The different
actions are visible to the transport layer (although in a slightly harder-to-parse location than the
proper method field), and server routers can easily declare separate handlers for each action.

<p>
But it is certainly not REST. In fact, it regresses on the Richardson Maturity Model from even the
hidden input hack, all the way back down to 0.
Where the hidden input at least used URIs to identify resources, now the URIs don't even represent
resources anymore; they represent a combination of resource and method, mixing the
semantics of both.

<p>
In addition to minor inconveniences like making it more cumbersome to filter logs, the greater impact of this is to unmoor the application from any universal semantics.
The standardized HTTP methods guide the developer to a clear and consistent pattern.
If the developer is not presented with a consistent set of common verbs for common tasks, they are liable to invent their own.
Why shouldn't <code>/put</code> be <code>/create</code>, or <code>/delete</code> be <code>/remove</code>?<f-note>
You might reasonably wonder why this is bad, when earlier we discussed how interesting opportunities that would be available if methods were entirely arbitrary.
The answer is: because telling the user agent what the method is lets it pilot new features and be resilient to ones it doesn't understand.
When extensions like these are tried out in the method slot, the user agent can choose to optimize them if they are recognized—like trusting the idempotence or GET or PUT—or
fallback to a baseline behavior if they are not.
Of course, HTTP <em>already</em> has features that differentiate GET, POST, PUT, and DELETE, so the question of whether browsers might build features around those is not theoretical—they already do.
</f-note>

<p>
The obvious smell of this pattern, when placed next to the actual HTTP methods, leads developers to conclude, correctly, that the missing methods limitation is endogenous to HTML, and the solution is to augment or abandon HTML rather than throw out URI semantics along with them.

<h3 id=rest-server-support>REST Support in Server Frameworks</h3>

<p>
Support for all HTTP methods is widespread in server side frameworks.  Currently, this support is
mainly used for JSON-based APIs, since JavaScript-based network interactions via technologies like
<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XmlHttpRequest</a> (xhr)
or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code></a> allow
JavaScript developers to access these HTTP methods.


<p>
Below is a table of some major server side frameworks in various programming langauges, and their support
for HTTP methods.

<table>
<thead>
<tr>
  <th>Language</th>
  <th>Framework</th>
  <th>HTTP Method Support</th>
</tr>
</thead>
<tr>
  <td rowspan="3">JavaScript</td>
  <td>
    <a href="https://expressjs.com">
      Express
    </a>
    </a>
    </a>
  </td>
  <td>
    <a href="https://expressjs.com/en/4x/api.html#app">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://nextjs.org">
      Next.js
    </a>
  </td>
  <td>
    <a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers#supported-http-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://astro.build">
      Astro
    </a>
  </td>
  <td>
    <a href="https://docs.astro.build/en/guides/endpoints/#http-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td rowspan="2">Python</td>
  <td>
    <a href="https://flask.palletsprojects.com/en/3.0.x/">
      Flask
    </a>
  </td>
  <td>
    <a href="https://flask.palletsprojects.com/en/3.0.x/quickstart/#routing">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://www.djangoproject.com/">
      Django
    </a>
  </td>
  <td>
    <a href="https://docs.djangoproject.com/en/5.0/topics/http/urls/">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>.NET</td>
  <td>
    <a href="https://dotnet.microsoft.com/en-us/apps/aspnet">
      ASP.NET
    </a>
  </td>
  <td>
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-8.0">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td rowspan="2">Java</td>
  <td>
    <a href="https://spring.io/guides/gs/spring-boot">
      Spring Boot
    </a>
  </td>
  <td>
    <a href="https://spring.io/guides/tutorials/rest">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://javalin.io/">
      Javalin
    </a>
  </td>
  <td>
    <a href="https://javalin.io/documentation#handlers">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>Go</td>
  <td>
    <a href="https://pkg.go.dev/net/http">
      Core HTTP Library
    </a>
  </td>
  <td>
    <a href="https://pkg.go.dev/net/http#pkg-constants">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>PHP</td>
  <td>
    <a href="https://laravel.com/">
      Laravel
    </a>
  </td>
  <td>
    <a href="https://laravel.com/docs/11.x/routing#available-router-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
</table>


<h3>REST Support in Client Libraries</h3>

<p>
Support for all HTTP methods is also widespread in client-side frameworks.
Interestingly, this support is increasingly used for HTML-based APIs, in additional to JSON-based APIs, indicating that there is demand for a full implementation of HTTP methods in HTML.

<p>
Below is a table of client side frameworks that use HTML as a network format, as well as their support for the various HTTP.

<table>
  <thead>
  <tr>
    <th>Framework</th>
    <th>HTTP Method Support</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <a href="https://htmx.org">
        htmx
      </a>
    </td>
    <td>
      <a href="https://htmx.org/docs/#ajax">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://unpoly.com/">
        Unpoly
      </a>
    </td>
    <td>
      <a href="https://unpoly.com/up.request#options.method">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://alpine-ajax.js.org/">
        Alpine-Ajax
      </a>
    </td>
    <td>
      <a href="https://alpine-ajax.js.org/examples/delete-row/">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://github.com/defunkt/jquery-pjax/">
        pjax
      </a>
    </td>
    <td>
      <a href="https://github.com/defunkt/jquery-pjax?tab=readme-ov-file#pjax-options">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://turbo.hotwired.dev/">
        Hotwire Turbo
      </a>
    </td>
    <td>
      <a href="https://discuss.hotwired.dev/t/destroy-record-in-turbo-frame/2731">
        All HTTP Methods
      </a>
    </td>
  </tr>
  </tbody>
</table>

<h3>Usage of Non-GET &amp; Non-POST Methods</h3>

<p>
While the above table establishes the general support for the full gamut of HTTP methods, it does not establish the
usefulness of them for web developers.  In order to get a feel for that, we can search Github for use of the following
htmx attributes: <code>hx-put</code>, <code>hx-patch</code> &amp; <code>hx-delete</code>, which are used to issue
  the HTTP <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code> methods respectively.

<p>
Below is a table of the results of these searches:

<table>
  <thead>
  <tr>
    <th>Attribute</th>
    <th>Count</th>
    <th>% of <code>hx-get</code></th>
    <th>% of <code>hx-post</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <code>hx-get</code>
    </td>
    <td>
      35.2k
    </td>
    <td>
      100%
    </td>
    <td>
      -
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-post</code>
    </td>
    <td>
      22.5k
    </td>
    <td>
      64%
    </td>
    <td>
      100%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-put</code>
    </td>
    <td>
      3.8k
    </td>
    <td>
      11%
    </td>
    <td>
      17%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-patch</code>
    </td>
    <td>
      1.2k
    </td>
    <td>
      3%
    </td>
    <td>
      5%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-delete</code>
    </td>
    <td>
      6.5k
    </td>
    <td>
      18%
    </td>
    <td>
      29%
    </td>
  </tr>
  </tbody>
</table>

<p>
You can see that there is widespread use of the three additional methods in htmx-based applications, particularly
<code>hx-put</code> and <code>hx-delete</code>.  It is worth noting the popularity of the <code>DELETE</code> method
in HTML-based web applications.  This is because it allows web developers to issue two different methods to the same
URL. A  web developer can use <code>POST</code> to <code>/reservations/</code> to create a new reservation and
a <code>POST</code> to <code>/reservations/123</code> to update an existing reservation (even if they would prefer to
issue a <code>PUT</code> or <code>PATCH</code>) but must create a separate end-point (or use another workaround) to
delete that reservation.

<p>
With the addition of the <code>DELETE</code> method, web developers can follow the natural, resource-oriented URL
pattern.

<h2>Additional Benefits</h2>
<div class=notice>This section is unfinished</div>

<h3>Simplify Application Servers</h3>

<p>
Let you use routers better

<p>
Many server frameworks support it

<h3>Encourage Security Best Practices</h3>
<p>
Encourage same-origin, proper URI use

<h3>Encourage Semantic HTML For Future Performance Gains</h3>

<p>
Anything written in HTML can be improved over time; moves critical web app functionality into HTML.

<p>
Caching and perf gains to be had with better HTTP method use

<h2>Alternatives and Additions</h2>
<h3>Omit PATCH</h3>
<p>
PUT and DELETE are necessary to include a full CRUD grammar in HTML; PATCH is not.

<p>
If you are going to do the work to generalize the <code>&lt;/form&gt;</code> method attribute anyway, it doesn't seem like there's huge benefit to omitting PATCH. Nevertheless, the proposal could mostly success in its goals without PATCH, since most RESTful design practices focus on PUT and DELETE.

<h3 id=alternative-cors-support>Include CORS Support</h3>
<p>
Between supporting a same-origin mode for form navigation versus implementing CORS for form navigation, spec editors have indicated that the former is the less-difficult option.<f-note>
<a href="https://github.com/whatwg/html/issues/3577#issuecomment-625880214">@annevk:</a>
<q>Same-origin is probably less work than CORS, but it's still a lot of work.</q>
</f-note>
In the interest of minimizing the barriers to implementation, we recommend starting with a same-origin mode—which still leaves the door open to CORS support in the future.

<p>
If, however, implementers were interested in supporting cross-origin PUT, PATCH, and DELETE requests right out of the gate, we would have no objection. After all, the fetch spec supports CORS for these methods, there's no reason HTML shouldn't.

<p>
If and when CORS support is eventually added, a redirect to a cross-origin server should trigger a preflight request to that new server, <a href="https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2">to match the spec</a>, and cancel navigation with an error if the new server does not respond with the appropriate CORS headers.
It's possible that new, navigation-specific CORS headers could be added as well.

<h3>Allow for DELETE request bodies</h3>
<p>
There's no inherent reason why a DELETE request couldn't send body content, and many popular
frameworks, like ExpressJS, do support it. Nor is DELETE content expressly prohibited by the spec,
which allows for such requests if the origin server has indicated that it supports them.
Since most HTML forms are same-origin, it could make sense to allow the form to indicate that it would be
fine with DELETE content,

<p>
A <code>usebody</code> attribute could be included to indicate support. If present, the form
would send its data as part of the body, for DELETE (or GET) requests; it would be ignored for all
other methods.



<!-- Within this framework, we can understand HTTP methods as part of the manipulation semantics; they -->
<!-- signify how the enclosed representation is to be processed. -->

<section class=footnotes>
<h2>Footnotes</h2>
</section>


<script>
// Create <section-ref> element
class SectionRef extends HTMLElement {
  connectedCallback() {
    const content = this.innerHTML
    const ref = this.attributes.ref.value
    this.innerHTML = `<a href="#${ref}">${content}</a>`
  }
}

customElements.define('section-ref', SectionRef)
// Create <f-note> element
class Footnote extends HTMLElement {
  static numFootnotes = 0

  connectedCallback() {
    Footnote.numFootnotes += 1

    this.content = this.innerHTML
    this.num = Footnote.numFootnotes
    this.innerHTML = `<sup id="fn-${this.num}"><a href="#ref-${this.num}">[${this.num}]</a></sup>`
  }
}
customElements.define('f-note', Footnote)

// Create footnotes section
const footnotesSection = document.querySelector('section.footnotes')
const footnotes = document.querySelectorAll('f-note')
for (footnote of footnotes) {
  const p = document.createElement('p')
  p.classList.add('footnote')
  p.id = `ref-${footnote.num}`
  p.innerHTML = `[${footnote.num}] ${footnote.content} <a href="#fn-${footnote.num}">↩</a>`
  footnotesSection.append(p)
}

// Create table of contents
const toc = document.querySelector('details.toc')
const headings = document.querySelectorAll('h2,h3')
const topList = document.createElement('ol')
let currentH2
for (heading of headings) {
  // Create an id if one doesn't exist
  heading.id = heading.id || heading.innerText.replace(' ', '-')
  if (heading.tagName === 'H2') {
    currentH2 = document.createElement('li')
    currentH2.innerHTML = `<a href="#${heading.id}">${heading.innerText}</a><ol></ol>`
    topList.append(currentH2)
  } else {
    const h2Sublist = currentH2.querySelector('ol')
    const h3Item = document.createElement('li')
    h3Item.innerHTML = `<a href="#${heading.id}">${heading.innerText}</a><ol></ol>`
    h2Sublist.append(h3Item)
  }
}
toc.append(topList)

</script>

<!-- https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-10 -->
