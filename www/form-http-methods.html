<!DOCTYPE HTML>
<title>Support PUT, PATCH, and DELETE in HTML Forms</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="./specwriter.css">
<script defer src="./specwriter.js"></script>

<h1>Support PUT, PATCH, and DELETE in HTML Forms</h1>

<dl>
  <dt>Authors</dt>
  <dd>
    Alexander Petros (<a href="mailto:contact@alexpetros.com">contact@alexpetros.com</a>)<br>
    Carson Gross (<a href="mailto:carson@bigsky.software">carson@bigsky.software</a>)
  </dd>
  <dt>Date Created</dt>
  <dd>August 17, 2024
  <dt>Last Updated</dt>
  <dd>August 26, 2024
  <dt>Issue Tracker</dt>
  <dd><a href="https://github.com/whatwg/html/issues/3577#issuecomment-2294931398">WHATWG Issue #3577</a> </dd>
  <dt>Status</dt>
  <dd>Published</dd>

</dl>

<noscript>
  Both the table of contents and the footnotes are generated with Javascript.
  It works this way because I want to be able to edit the proposal as a single HTML file, without any build steps.
  If you're viewing this with no scripting, it will display footnotes inline with yellow highlighting.
</noscript>

<details class=toc open>
<summary>Table of Contents</summary>
<table-of-contents></table-of-contents>
</details>


<h2>Summary</h2>
<p>
A proposal for adding PUT, PATCH, and DELETE support to HTML forms.

<p>
Proposal 1/3 in the <a href="https://alexanderpetros.com/triptych/">Triptych Proposals</a>.

<h3>Goals</h3>
<p>
PUT, PATCH, and DELETE support in forms should:

<ul>
  <li>be the path of least friction for developing RESTful web services
  <li>fit seamlessly within existing form semantics
  <li>integrate with existing servers and frameworks that support those methods
  <li>not introduce new security considerations
</ul>

<h2 id=proposed-changes>Proposed Changes</h2>
<p>
New values for the form <code>method</code> attribute:
<ul>
  <li><code>PUT</code> - makes the form issue a PUT request
  <li><code>PATCH</code> - makes the form issue a PATCH request
  <li><code>DELETE</code> - makes the form issue a DELETE request
</ul>

<p>
All new method keywords are case insensitive.
Existing form controls (e.g. <code>action</code>, <code>enctype</code>) should operate identically.

<h2 id=sample-usage>Sample Usage in Resource Lifecycle</h2>

This section demonstrates how PUT and DELETE methods are necessary for managing the lifecycle of a resource.
We use as an example a hypothetical hotel reservation service, in which users have the ability to book hotel rooms.

<p>
All examples in this section assume that the host origin is https://example.com.

<h3 id=basic-create-form>Creating A Resource</h3>

<p>
First, the user makes a reservation using a traditional POST form:<f-note>While PUT is capable of creating new resources, POST is preferred when the service <q><a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-10">selects a proper URI on behalf of the client.</a></q>
This is the simplest RESTful pattern, and has the additional benefit of using a non-idempotent method, so the browser can guard against creating two new things when only one is desired.
More benefits to using this pattern will be discussed in the justifications section.
</f-note>
</p>

<pre class=code>
&lt;form action="/reservations" method="POST"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;input type="date" name="check-in"&gt;
  &lt;input type="date" name="check-out"&gt;
  &lt;input type="checkbox" name="has-pets"&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>

The browser will send the following HTTP request:

<pre class=code>
POST /reservations HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-02&has-pets=on
</pre>

And the server responds with a redirect to the newly-created reservation resource:<f-note>
The <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.4-1">303 SEE OTHER</a> status code is used here because it directs the agent to make the subsequent request as GET, regardless of what method the original request used. 302 FOUND does not do this this, but for historical reasons, browsers <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.3-3.1">typically change POST to GET</a>, while leaving PUT, PATCH, and DELETE methods as is. For this reason, we use 303 for everything.
</f-note>


<pre class=code>
HTTP/1.1 303 SEE OTHER
Location: /reservations/123
</pre>

<h3 id=basic-put-form>Updating A Resource</h3>

<p>
At the reservation page, the user is presented with two forms. The first one allows them to adjust
their reservation:


<pre class=code>
&lt;form action="/reservations/123" method="PUT"&gt;
  &lt;input type="text" name="name" value="Alex Petros"&gt;
  &lt;input type="date" name="check-in" value="2024-12-01"&gt;
  &lt;input type="date" name="check-out" value="2024-12-02"&gt;
  &lt;input type="checkbox" name="has-pets" checked&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>


This new form offers the same controls as the POST form, but with some key differences:<f-note>
The significance of these changes will be discussed more in <section-ref ref=completing-rest>Completing REST</section-ref>.
</f-note>


<ul>
  <li>The action has changed from <code>/reservations</code> to <code>/reservations/123</code>
  <li>The method has changed from <code>POST</code> to <code>PUT</code>
  <li>The forms are pre-filled with the values saved at the server.
</ul>

<p>
If the user changes the check-out date to <code>2024-12-03</code>, the browser will send the
following request:


<pre class=code>
PUT /reservations/123 HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-03&has-pets=on
</pre>


The server can then choose to either send back a new page or redirect to one.

<h3 id=basic-delete-form>Deleting A Resource</h3>

The second form on the reservation page allows the user to delete their reservation:<f-note>
In Bugzilla Issue #10671, <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c16">Ian Hickson wrote</a>: <q>PUT as a form method makes no sense, you wouldn't want to PUT a form payload. DELETE only makes sense if there is no payload, so it doesn't make much sense with forms either.</q>
<br>
While we disagree with this comment for the many of the same reasons that <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c18">Cameron Jones</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c21">Tom Wardrop</a> did originally, there is one limited sense in which Hickson's comment is correct: it doesn't make much sense that you have to wrap a button in a form tag to issue a payload-less DELETE request.
We address this limitation in <a href="/triptych/button-requests">Triptych Proposal #2: Button HTTP Requests</a>.
</f-note>


<pre class=code>
&lt;form action="/reservations/123" method="DELETE"&gt;
  &lt;button&gt;Delete Reservation&lt;/button&gt;
&lt;/form&gt;
</pre>


Clicking "Delete Reservation" would result in the following HTTP request:


<pre class=code>
DELETE /reservations/123 HTTP/1.1
Host: example.com
</pre>


And the server could choose to either send a delete confirmation page, or redirect elsewhere.


<h2>Technical Specification</h2>

<h3>Rendering</h3>
If the response status code is not a redirection code (300-399), the browser should display the body
of the response in the page, exactly the same way it would for the response of a POST form.
It should likewise update the page URL and history.

<p>
Browsers should identically render the response content for all non-redirection codes;
we do not propose any special behavior for codes like 201 (Created) or or 500 (Internal Server Error).
This aligns with current browser behavior.

<h3>Redirection</h3>
<p>
For PUT, PATCH, and DELETE requests, if the server responds with a 301, 302, or 307 status code, the browser should perform a subsequent request with the same HTTP method;
if the server responds with a 303 status code, the browser should perform a subsequent request with the GET method.<f-note>
When browsers receive a 302 response to a POST form, they typically follow that redirect
automatically and change the method to GET;
there is no need for this behavior to apply to PUT, PATCH, and DELETE.
Changing POST to GET in this fashion is a backwards compatibility carveout in the spec, which has not been applied to other methods in browsers' fetch implementations.
Using a 303 to perform POST-redirect-GET flow (replacing POST with PUT or DELETE) is already a well-understood pattern for server frameworks that support these methods, so no additional carveouts are needed to integrate with them.

For instance, <a
  href="https://stackoverflow.com/questions/33214717/why-post-redirects-to-get-and-put-redirects-to-put">ExpressJS</a>
and <a href="https://stackoverflow.com/questions/71975005/rails-not-redirecting-on-put-request-sending-406-back-instead">Rails</a>.
</f-note>
This resolves a blocker for the original Firefox beta implementation.<f-note>
On 01/12/2011, at 9:57 PM,
<a href="https://lists.w3.org/Archives/Public/public-html-comments/2011Apr/0000.html">
Julian Reschke wrote:</a>
<q>One thing I forgot earlier, and which was the reason why I actually wanted PUT and DELETE
temporarily (!) on hold is redirect handling. The experimental Firefox implementation was copying
the redirect handling for POST (with respect to method rewriting), and it would have been bad to let this get into the deployed platform.
The experimental Firefox implementation was copying the redirect.
So it would be good to clarify that PUT and DELETE, when being redirected by 301/302 should *not* be rewritten to GET.</q>
</f-note>

<p>
If the response redirects to a server of the same origin, the browser should directly issue the request.
For behavior when the response redirects to a server of a different origin, see <section-ref ref=Security-Profile>Security Profile</section-ref>.

<h3 id=body-content>Body Content</h3>

<p>
PUT and PATCH forms should send identical content to their POST equivalents.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#appendix-B.3-5">"Content" was previously known
  as "payload"</a> or "payload body", and is set using the <code>body</code> property of a fetch
request.
</f-note>

<f-note>
All three methods support the same Content-Type headers, and they are differentiated from each
other based on the intent for the enclosed representation, not the representation itself.
Per <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-put">RFC9110</a>, the difference
between POST and PUT <q>is highlighted by the different intent for the enclosed representation,</q>
which implies that they support the same set of representations. Per
<a href="https://www.rfc-editor.org/rfc/rfc5789">RF5789</a>, which defines PATCH, <q>the
difference between the PUT and PATCH requests is reflected in the way the server processes the
enclosed entity to modify the resource</q>, which again implies that they are capable of
representing resources the same way.
</f-note>
Server frameworks that support PUT and PATCH handle their bodies identically to POST bodies;
the vast majority of servers will support the new feature out of the gate.<f-note>
For examples, see <section-ref ref="rest-server-support">REST Support in Server Frameworks</section-ref>
</f-note>

<p>
DELETE forms should format their content as URL parameters, like GET forms. While both GET and
DELETE body semantics are technically undefined, including content in the request body is somewhat
discouraged by the spec.<f-note>
While <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-delete">RFC9110</a> states that a
<q>DELETE request has no generally defined semantics,</q> it also states that <q>a client SHOULD NOT
generate content in a DELETE request unless it is made directly to an origin server that has
previously indicated, in or out of band, that such a request has a purpose and will be adequately
supported</q>. While one could certainly argue that the server returning HTML with <code>&lt;form
  method=DELETE&gt;</code> constitutes indication of support for content, we defer to the library
ecosystem, which generally understands the similar language in the GET and DELETE specs as a tacit
discouragement of body content for both.
</f-note>
Therefore, forms with <code>method=DELETE</code> should encode their inputs as part the URI,
emulating the behavior of forms with no <code>method</code>, or <code>method=GET</code>.<f-note>
While many server frameworks are agnostic to the relationship between HTTP methods and the body of the HTTP request, one notable exception is the golang standard library's <a href="https://pkg.go.dev/net/http#Request.ParseForm">ParseForm</a> function, which reads POST, PUT, and PATCH requests as urlencoded forms, but ignores the body if the request has any other method.
</f-note>

<h3>Caching</h3>
<p>
PUT, PATCH, and DELETE requests are <a href="https://httpwg.org/specs/rfc9110.html#safe.methods">
unsafe</a> (not read-only), and therefore can never be cached.

<p>
PATCH <em>responses</em> are technically cacheable in the same way that POST responses are: if
certain information is explicitly provided, subsequent GET requests may use the cached PATCH
response to represent that resource.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc5789#section-2">RFC 5789 Section 2</a>,
</f-note> Browsers that implement this behavior for POST requests should do so for PATCH requests,
although the spec notes that the overwhelming majority of cache implementations do not.<f-note>
  <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.3-2">RFC 9110 Section 9.2.3</a>
</f-note>

<p>
PUT and DELETE responses are never cacheable.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-13">RFC 9110 Section 9.3.4</a>,
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.5-7">Section 9.3.5</a>
</f-note>

<h3 id=cors>Cross-Origin Resource Sharing (CORS)</h3>
<p>
For same-origin requests, the browser should directly issue the request. For cross-origin requests, the browser should do the following:

<ol>
  <li>Issue a CORS preflight request to the URI at the <code>action</code> attribute.</li>
  <li>If the server responds indicating that the request is not allowed, throw an error (visible to the user, in the same manner as an infinite redirect or bad certificate)</li>
  <li>Otherwise, issue the request.</li>
  <li>If the server responds with a redirect, issue a new CORS request
    <ol>
      <li>If the server responds indicating that the request is allowed, navigate to the page</li>
      <li>If the server responds indicating that the request is not allowed, throw an error</li>
      <li>If the server responds with a redirect, go to step 4</li>
    </ol>
  </li>
  <li>Otherwise, navigate to the page
</ol>

<p>
The behavior where the browser issues additional CORS requests if the server responds with a redirect is chosen to match the <a href="https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2">existing behavior</a> in the fetch spec.
<f-note>
The fetch spec will actually have to be amended slightly to unpeg CORS from forms capabilities, since we advocate for extending form capabilities without adding to the <a href="https://fetch.spec.whatwg.org/#cors-safelisted-method">CORS-safelisted methods</a> or <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">CORS-safelisted request headers</a>.
Specifically, <a href="https://fetch.spec.whatwg.org/#general">the part</a> that says: <q>for requests that are more involved than what is possible with HTML's form element, a CORS-preflight request is performed, to ensure request’s current URL supports the CORS protocol.</q>
</f-note>


<p>
Applying CORS to navigation was an implementation blocker for quite some time, as no precedent previously existed for this behavior.<f-note>
<a href="https://github.com/whatwg/html/issues/3577#issuecomment-625375374">@annevk on issue #3577</a> <q>We cannot bypass the same-origin policy and enforcing CORS is theoretically possible, but would require integration of that to some extent with navigation, which is completely new ground.</q>
</f-note>
Progress in Private Network Access draft specification, however, has provided a concurrent justification for revisiting it.<f-note>
We refer specifically to its <a href="https://wicg.github.io/private-network-access/#example-deny-by-default">application of CORS to link navigation.</a>
</f-note>
As such, this proposal models its algorithm to re-use the work from that proposal and reduce implementation complexity accordingly.

<p>
It's possible that new, navigation-specific CORS headers could be added as well.

<h3>Refresh Behavior</h3>
<p>
For PATCH requests, which are not idempotent, the user agent should behave as it does currently, asking the user for confirmation and warning that it may cause the data to be re-submitted.

<p>
For PUT and DELETE requests, which are idempotent, the user agent should resubmit the request.
This allows servers to take advantage of the method semantics and create forms that users on unreliable connections can feel confident re-submitting.

<h2 id=Security-Profile>Security Profile</h2>
<h3>Client Capabilities</h3>
<p>
First and foremost, new browser features must not expose existing servers or users to new vulnerabilities, so adding new CORS-safelisted methods or headers is out of the question.
Fortunately, there is no need to do so.

<p>
PUT, PATCH, and DELETE forms only make available to HTML a highly useful subset of what is <em>already available</em> to the web page, via JavaScript.
Nothing is proposed that can't be accomplished currently with <code>fetch</code> and <code>FormData</code>.

<p>
Technically, this does increase the capabilities of clients that that have scripting disabled.
The overwhelming majority of browser users, however, especially the ones most vulnerable to malicious websites, have scripting enabled.
Servers obviously cannot build webpages that are only secure for users with scripting disabled, so this does not change the security profile of the server.

<p>
The only HTML control that this proposal alters is the form's <code>method</code> attribute.
Because the only two supported methods, GET and POST, have such different purposes, it is highly unlikely that authors are setting this attribute dynamically; it is even less likely that authors are setting it dynamically with un-escaped user-generated input, and relying on the browser's incomplete implementation of HTTP methods to protect against XSRF.
The spec has never guaranteed that these would be the only two methods, and it's hard to imagine a practical use that would lead an author to that implementation.

<h3>Opportunity For a Pit of Success</h3>
<p>
The addition of CORS-restricted methods to HTML forms provides a massive opportunity to move developers onto a more secure pattern web applications.
PUT, PATCH, and DELETE requests are more secure, by default, than POST requests, because they will <em>never</em> be issued to a cross-origin server unless that server explicitly permits them.<f-note>
This is another, highly significant, reason not to tunnel PUT and DELETE through POST requests with ad-hoc semantics, one that did not exist when Amundsen et. al were arguing for PUT and DELETE support in
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c4">WHATWG Bug 10671</a>.
</f-note>
Because POST is the only unsafe method currently available to HTML forms, the introduction of PUT and DELETE necessarily displaces usage of POST methods, reducing the number of webforms that are vulnerable to CSRF due to backwards compatibility concerns.<f-note>
It also opens the door for the possibility of introducing a new method (i.e. CREATE) that serves a similar purpose to POST but is unburdened by the same backwards compatibility concerns.
POST could continue to serve as a <a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post"><q>this action isn't worth standardizing</q></a> method, and work for legacy applications.
</f-note>

<!-- <a href="https://github.com/httpwg/http-extensions/issues/2228">@annevk on issue #2228</a> <q>changes to form submission will be hard. And almost definitely any new kind of cross-origin method would require some kind of opt-in as the safety we care about is not that of the method definition of safety, but that of end users.</q> -->


<!-- Giving developers access to them in HTML dramatically reduces the difficulty of taking advantage of these more-secure methods. -->

<p>
In this manner, CORS restrictions can be leveraged to deepen the web security pit of success.
Sites that make no cross-origin requests are easier to secure than sites that do.<f-note>
CORS and the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value">SameSite Attribute</a> dramatically reduce the opportunity for attackers to execute cross-site requests.
</f-note>
Sites that use REST verbs properly are easier to secure than sites that don't.<f-note>
The <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSRF">MDN Page for CSRF</a> ends with this note: <q>There are many ways to prevent CSRF, such as implementing [sic] RESTful API, adding secure tokens, etc.</q>
Unfortunately, it doesn't describe how a RESTful API might mitigate CSRF.
What they likely mean by this is that ensuring GET requests do not have side effects mitigates a number of CSRF pathways, but it's also true that HTML does not does not properly support RESTful APIs, nor does it currently have the ability to make any unsafe HTTP requests that are fully protected by CORS.
For more on the importance of supporting REST and the ways in which HTML support is inadequate, see <section-ref ref=completing-rest>Completing REST</section-ref>.
</f-note>
Web forms that make using REST verbs trivial for same-site requests—especially REST verbs that are not safelisted by CORS—incentivize the simplest, most secure patterns by also making them the easiest to implement.


<h2 id=completing-rest>Completing REST</h2>
In 2000, Roy Fielding published a PhD dissertation in which he introduced the Representational State
Transfer (REST) architectural style for distributed hypermedia systems.
While these principles were used to guide the early development of the World Wide Web, they are
often badly misunderstood.<f-note>
Carson Gross notes in <a href="https://htmx.org/essays/hateoas/"><cite class=article>HATEOAS — An Alternative Explanation</cite></a> that the <a href="https://en.wikipedia.org/wiki/HATEOAS">Wikipedia Entry for "Hypertext as the engine of application state"</a>, one of REST's fundamental constraints, uses a JSON API as an example, even though JSON is not hypertext.
Roy Fielding is less polite: in <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven"><cite class=article>REST APIs must be hypertext-driven</cite></a>, he complains that a different "REST" API, which also did not user hypertext, has <q>so much coupling on display that it should be given an X rating.</q>
</f-note>

<p>
Despite the misconceptions, REST remains the most powerful conceptual tool for building durable hypermedia applications.
In this section, we make the case for how better method support in HTML can drive adoption of REST priciples and dramatically improve the median web application as a result.

<h3>REST in Theory</h3>

<p>
In the dissertation that defines REST, Roy Fielding includes HTTP methods among the core interface
constraints of REST—specifically the constraint that messages need to be self-describing.<f-note>
<a href="https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5">Section
  5.1.5:</a> <q>REST enables intermediate processing by constraining messages to be self-descriptive:
interaction is stateless between requests, standard methods and media types are used to indicate
semantics and exchange information, and responses explicitly indicate cacheability.</q>
</f-note>
He does not, however, address which methods are necessary.<f-note>
<a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post">Fielding, in 2009:</a> <q>Search my dissertation and you won't find any mention of CRUD or POST.
The only mention of PUT is in regard to HTTP's lack of write-back caching.
The main reason for my lack of specificity is because the methods defined by HTTP are part of the Web's architecture definition, not the REST architectural style.</q>
</f-note>
His main concern is that the name of the method should not affect the parsing of the HTTP request, as
that would require out-of-band agreement on method semantics and limit the extensibility of the
method field.<f-note>
<a href="https://ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_3_1_2">
  Section 7.3.1.2
</a>
</f-note>

<p>
Fielding actually appears to be somewhat ambivalent about whether the user agent should have
<em>any</em> understanding of method semantics. In 2008, he writes:

<blockquote>
<q>You don't get to decide what POST means — that is decided by the resource. Its purpose is
supposed to be described in the same context in which you found the URI that you are posting to.</q><f-note>
<a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-732">"REST APIs must be hypertext-driven", Comment #13</a>
</f-note>
</blockquote>

That GET, POST, and PUT have semantic meaning outside the context of the application is a secondary concern;
the primary obligation of the client is to allow the hypermedia API to describe itself, and then faithfully execute that description.<f-note>
Fielding's comments on method usage are somewhat contradictory.
In <cite class=article><a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post">It is okay to use POST</a></cite>, he seems broadly committed to the principle that the server gets to define what the methods mean, reminding readers that specific <q>method definitions (aside from the retrieval:resource duality of GET) simply don't matter to the REST architectural style</q>.
He also asks: <q>why shouldn't you use POST to perform an update? Hypertext can tell the client which method to use when the action being taken is unsafe.</q>

<br><br>

But in the next paragraph, he says that POST is an issue <q>when it is used in a situation some other method is ideally suited,</q> including <q>complete replacement of a representation (PUT)</q>.
So it's fine to use POST to update a resource, unless your update is a complete representation of that resource, in which case it's not?
Is it fine to use POST method to delete a resource, a task for which DELETE is ideally suited?

<br><br>
The most reasonable way to interpret Fielding's statements here (and the statements referenced in the following footnote) is that REST is primarily concerned with defending the distributed system's ability to write self-describing messages, but deliberately unconcerned with what those messages mean, as long as they do not violate any of the already-established out-of-band agreements enshrined within the protocols themselves.
This allows for some necessary compromises to the theoretical purity of self-description—like the user agent being able build security features around the knowledge that GET requests are safe—while still allowing for method extension and graceful fallback.
</f-note>

The HTML form element's transformation of any non-GET, non-POST method into a GET violates this principle.<f-note>
n.b. Fielding's <a
href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">"REST APIs must be
hypertext-driven" blog</a> does include the follow bullet:
<q>A REST API should not contain any changes to the communication protocols aside from filling-out
or fixing the details of underspecified bits of standard protocols, such as HTTP's PATCH method or
Link header field. Workarounds for broken implementations (such as those browsers stupid enough to
believe that HTML defines HTTP's method set) should be defined separately, or at least in
appendices, with an expectation that the workaround will eventually be obsolete.</q>
Exactly what he means by <q>browsers stupid enough to believe that HTML defines HTTP's method set</q> is a little vague, but it clearly demonstrates frustration with HTML's limited method support.
</f-note>

<p>
We do not propose that HTML execute arbitrary HTTP methods specified in the form's method attribute, although that would fit nicely within the REST guidelines by allowing web APIs to freely self-describe across an already-available dimension.<f-note>
This is neverthless an intriguing idea.
If HTML allowed the use of arbitrary HTTP methods, developers could pilot new client networking semantics in a backwards-compatible fashion.
This concept was actually included in <a href="https://www.w3.org/TR/form-http-extensions/#introduction">W3C HTML Form HTTP Extensions</a>, another previous attempt to get these methods into HTTP forms.
We choose to omit it here in an effort to reduce to surface area of this change, and make it more likely to be accepted.
</f-note>
Instead, we simply urge that HTML support the relevant, existing HTTP methods, which are so useful that they are universally-supported by servers in spite of their absence from the HTML standard.

<h3>REST in Practice</h3>

<p>
HTTP methods have become more central to the developer community's conception of REST than
Fielding perhaps intended, and are one of its better-understood concepts.
In Jeremy Richardson's <a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html">Maturity Heuristic</a>, later dubbed the
<a href="https://martinfowler.com/articles/richardsonMaturityModel.html">"Richardson Maturity
  Model"</a> by Martin Fowler, proper use of HTTP methods is one of the three levels that determine
how well an application adheres to REST principles.<f-note>
Both of these explicitly sidestep the "controversy" about whether PUT and DELETE
should be supported by HTML. Fowler notes that in the absence of PUT and DELETE support in HTML,
what we essentially have in HTTP is GET and POST standing in for safe and unsafe requests,
respectively.
</f-note>

<ol start=0>
  <li>Using HTTP
  <li>Using resource URIs
  <li>Using HTTP verbs (methods)
  <li>Responding with hypermedia
</ol>

<p>
The increased salience of HTTP methods to REST is not a perversion of the concept, but a practical evolution of it, born from real-world use.
Aspirational REST adherents have discovered that it is much easier to uphold a consistent representation of a resource (via URIs) when you have a standardized semantic for to describe <em>how</em> the enclosed resource is to be modified.

<p>
For instance, this overview is from the first API tutorial in the latest ASP.NET Core documentation:<f-note>
<a
  href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&tabs=visual-studio">Tutorial:
  Create a web API with ASP.NET Core</a>; interestingly, this tutorial doesn't even mention REST,
although it does link to another page describing RESTful APIs.
</f-note>

<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
<th>Request body</th>
<th>Response body</th>
</tr>
</thead>

<tr>
<td><code>GET /api/todoitems</code></td>
<td>Get all to-do items</td>
<td>None</td>
<td>Array of to-do items</td>
</tr>
<tr>
<td><code>GET /api/todoitems/{id}</code></td>
<td>Get an item by ID</td>
<td>None</td>
<td>To-do item</td>
</tr>
<tr>
<td><code>POST /api/todoitems</code></td>
<td>Add a new item</td>
<td>To-do item</td>
<td>To-do item</td>
</tr>
<tr>
<td><code>PUT /api/todoitems/{id}</code></td>
<td>Update an existing item &nbsp;</td>
<td>To-do item</td>
<td>None</td>
</tr>
<tr>
<td><code>DELETE /api/todoitems/{id}</code> &nbsp; &nbsp;</td>
<td>Delete an item &nbsp; &nbsp;</td>
<td>None</td>
<td>None</td>
</tr>

</table>

<p>
This how most developers understand REST: a service is RESTful if it uses methods and URIs to describe what <strong>action</strong> you're taking on what <strong>resource</strong>.
But if you look closely, you'll notice that it's not REST: the API returns JSON data, not hypermedia. The popular conception of REST is stuck at Level 2 of the Richardson Maturity Model.

<p>
Developers choose to build APIs with the standardized method grammar—in spite of missing HTML support—because it's simpler.
An API that supports <code>PUT /users/123</code> and <code>DELETE /users/123</code> is easier to
describe and code than a <code>POST /users/123</code> API whose body semantics alter how it processes the enclosed resource.

<p>
The usefulness of methods as an HTTP semantic—<i>a priori</i> to the semantics of the methods
themselves—is so self-evident that the hypertext transfer protocol has long standardized a bunch of
additional methods; all that remains is for the dominant hypertext markup to support them.<f-note>
The purpose of describing REST in this detail, and the "REST in Practice" subsection in particular,
is to make clear that REST is not an ivory tower architecture that developers have failed to follow; it's an attempt to explain the best real-world developer practices and model the ways in which user agents can support them. The lack of proper method support is a <a href="https://www.w3.org/TR/html-design-principles/#solve-real-problems">real problem</a> that developers continually work around. For evidence of this, see <section-ref ref=ecosystem-demand>Ecosystem Demand</section-ref>.
</f-note>

<h3>The Limits of Scripting</h3>

<p>
REST is an enduring paradigm that suites a wide variety of web applications, and developers today have a number of good libraries to choose from if they wish to implement it.
But even a client-loaded library with the perfect interface can never replace the functionality or durability of an official implementation.

<p>
Most libraries that implement REST primitives use them with partial page replacement.
This is largely due to demand in the developer ecosystem for partial page replacement, but it masks an important limitation: JavaScript cannot modify browser navigation primitives.<f-note>
To be clear, this is a very reasonable limitation—JavaScript probably <em>shouldn't</em> be able to do that.
That's why this will require expanding the <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#beginning-navigation">navigation spec</a> to include resources for additional methods.
</f-note>
A form that makes POST request "navigates" to that URL, displaying the results on the page and resetting the JavaScript environment; no JavaScript-based implementation of the PUT method can perform the same task.<f-note>This is the biggest weakness of the <a href="https://github.com/alexpetros/triptych">Triptych Polyfill</a>, that it cannot make PUT form requests that navigate to an entirely new page, therefore cannot properly implement POST-redirect-GET (with PUT instead of POST).
It cannot even intercept 303 redirects and manually navigate to them, because the location header is not available in fetch's manual redirect mode.
</f-note>
While partial page replacement is useful for highly interactive applications, full page navigation is a much more accessible and secure paradigm.<f-note>
Among the <a href="https://unplannedobsolescence.com/blog/hard-page-load/">many reasons for this</a> are that end-users can use browser controls to manage "hard" navigations—and browsers can optimize around that behavior without any addition effort from users or page authors.
</f-note>


<p>
Given HTML's tremendous backwards- and forwards-compatibility guarantees, its capabilities guide the design of durable interactive applications.
For instance, the vast majority of Wikipedia's functionality can be described with hypertext primitives—including its relatively limited interactivity.<f-note>
Wikipedia obviously supports enormous traffic, but the type of interactivity is mostly limited to creating and updating hypertext pages, as well as managing a user account, neither of which push the limits of what an HTML form can currently describe.
The addition of <code>method=DELETE</code> might be helpful for something like deleting a comment on a user talk page, but by and large, Wikipedia's core functionality does not involve a lot of deleting things, so the compromises involved with representing the deletions it does has are minimal.
</f-note>
Not only can you browse Wikipedia with JavaScript disabled, you can create an account and edit pages too;
with scripting enabled, editing is augmented by a rich-text editor, but in most other respects the experience is close to identical.

<p>
Many applications that thrive on the web have more complicated resource lifecycles than Wikipedia, like banking, travel bookings, and social media.
The new lifecycle methods would make it possible for those applications to built their interactivity in a hypertext-driven style, and take full advantage of the browser's reliability, security, and longevity as an application platform.

<h2 id=ecosystem-demand>Ecosystem Demand</h2>

Lacking proper browser support, developers still consider method semantics important enough to their
API design that they come up with ad-hoc methods to achieve the same result.

<h3 id=hidden-input-hack>The Hidden Input Hack</h3>

<p>
The most common way that developers compensate for the lack of proper HTTP method support is to
include a hidden input that overrides the method.
<f-note>
For instance, <a href="https://unpoly.com/up.protocol.config#config.methodParam">unpoly</a> can automatically convert PUT forms into POST forms with an <code>&lt;input name=_method value=PUT&gt;</code> input.
</f-note>

<pre class="code">
&lt;form method="post" action="/users/123"...&gt;
  &lt;input type="hidden" name="_method" value="put"&gt;
  ...
&lt;/form&gt;

&lt;form method="post" action="/users/123"...&gt;
  &lt;input type="hidden" name="_method" value="delete"&gt;
  ...
&lt;/form&gt;
</pre>


<p>
This would be a Level 1 on the Richardson Maturity Model. The URIs consistently identify a
resource (<code>user/123</code>), but the method is always POST, so the verbs aren't in use.

<p>
This pattern has a number of drawbacks that would be rectified by proper PUT, PATCH, and DELETE
support:<f-note>
These points are not new; many of them were made by Mike Amundsen in the closed
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671#c4">WHATWG Bug 10671</a>.
</f-note>

<ul>
  <li>Unlike POST, PUT and DELETE are idempotent, which gives the user agent more leeway to recover from network failures
  <li>HTTP methods are typically logged while HTTP bodies are not; services that break up their unsafe requests across POST, PUT, and DELETE have a smaller surface to debug than ones where all unsafe request are tunneled through POST.
  <li>HTTP methods are a powerful filtering tool for debugging across the stack—server logs, application logs, and the browser network tab.
  <li>Routing is fundamental to server logic, and including an additional variable for routing dramatically simplifies the server logic that would otherwise have to compensate by performing additional routing imperatively.
  <li>PUT and DELETE do not have the same CORS exemptions that POST does, making them more secure for user agent (discussed in <section-ref ref=cors>CORS</section-ref>)
</ul>

<h3>Ad-hoc URI Semantics</h3>

<p>
Another workaround is to encode the method semantics straight into the URI.
</p>

<pre class="code">
&lt;form method="post" action="/users/123/put"...&gt;
  ...
&lt;/form&gt;

&lt;form method="post" action="/users/123/delete"...&gt;
  ...
&lt;/form&gt;
</pre>



<p>
This actually resolves some of the operational issues with the hidden input hack.
The different actions are visible to the transport layer (although in a slightly harder-to-parse location than the proper method field), and server routers can easily declare separate handlers for each action.

<p>
But it is certainly not REST. In fact, it regresses on the Richardson Maturity Model from even the hidden input hack, all the way back down to 0.
Where the hidden input at least used URIs to identify resources, now the URIs don't even represent resources anymore;
they represent a combination of resource and method, mixing the semantics of both.
The problem immediately becomes apparent when you try to add additional sub-resources after <code>/users/123</code>:
sometimes what comes after the <code>123</code> is an action, and sometimes it's a sub-resource.
This is a hassle to code, and it's a hassle to understand.

<p>
The overall impact is to unmoor the application from any universal semantics.
The standardized HTTP methods guide the developer to a clear and consistent pattern.
If the developer is not presented with a consistent set of common verbs for common tasks, they are liable to invent their own.
Why shouldn't <code>/put</code> be <code>/create</code>, or <code>/delete</code> be <code>/remove</code>?<f-note>
You might reasonably wonder why this is bad, when earlier we discussed how interesting opportunities that would be available if methods were entirely arbitrary.
The answer is: because telling the user agent what the method is lets it pilot new features and be resilient to ones it doesn't understand.
When extensions like these are tried out in the method slot, the user agent can choose to optimize them if they are recognized—like trusting the idempotence of GET or PUT—or
fallback to a baseline behavior if they are not.
Of course, HTTP <em>already</em> has features that differentiate GET, POST, PUT, and DELETE, so the question of whether browsers might build features around those is not theoretical—they already do.
</f-note>


<p>
The obvious smell of this pattern, when placed next to the actual HTTP methods, leads developers to conclude, correctly, that the missing methods limitation is endogenous to HTML, and the solution is to augment or abandon HTML rather than throw out URI semantics along with them.

<h3 id=rest-server-support>REST Support in Server Frameworks</h3>

<p>
Support for all HTTP methods is widespread in server side frameworks.  Currently, this support is
mainly used for JSON-based APIs, since JavaScript-based network interactions via technologies like
<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XmlHttpRequest</a> (xhr)
or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>fetch()</code></a> allow
JavaScript developers to access these HTTP methods.


<p>
Below is a table of some major server side frameworks in various programming langauges, and their support
for HTTP methods.

<table>
<thead>
<tr>
  <th>Language</th>
  <th>Framework</th>
  <th>HTTP Method Support</th>
</tr>
</thead>
<tr>
  <td rowspan="3">JavaScript</td>
  <td>
    <a href="https://expressjs.com">
      Express
    </a>
  </td>
  <td>
    <a href="https://expressjs.com/en/4x/api.html#app">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://nextjs.org">
      Next.js
    </a>
  </td>
  <td>
    <a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers#supported-http-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://astro.build">
      Astro
    </a>
  </td>
  <td>
    <a href="https://docs.astro.build/en/guides/endpoints/#http-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td rowspan="2">Python</td>
  <td>
    <a href="https://flask.palletsprojects.com/en/3.0.x/">
      Flask
    </a>
  </td>
  <td>
    <a href="https://flask.palletsprojects.com/en/3.0.x/quickstart/#routing">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://www.djangoproject.com/">
      Django
    </a>
  </td>
  <td>
    <a href="https://docs.djangoproject.com/en/5.0/topics/http/urls/">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>.NET</td>
  <td>
    <a href="https://dotnet.microsoft.com/en-us/apps/aspnet">
      ASP.NET
    </a>
  </td>
  <td>
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-8.0">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td rowspan="2">Java</td>
  <td>
    <a href="https://spring.io/guides/gs/spring-boot">
      Spring Boot
    </a>
  </td>
  <td>
    <a href="https://spring.io/guides/tutorials/rest">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>
    <a href="https://javalin.io/">
      Javalin
    </a>
  </td>
  <td>
    <a href="https://javalin.io/documentation#handlers">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>Go</td>
  <td>
    <a href="https://pkg.go.dev/net/http">
      Core HTTP Library
    </a>
  </td>
  <td>
    <a href="https://pkg.go.dev/net/http#pkg-constants">
      All HTTP Methods
    </a>
  </td>
</tr>
<tr>
  <td>PHP</td>
  <td>
    <a href="https://laravel.com/">
      Laravel
    </a>
  </td>
  <td>
    <a href="https://laravel.com/docs/11.x/routing#available-router-methods">
      All HTTP Methods
    </a>
  </td>
</tr>
</table>


<h3>REST Support in Client Libraries</h3>

<p>
Support for all HTTP methods is also widespread in client-side frameworks.
Interestingly, this support is increasingly used for HTML-based APIs, in additional to JSON-based APIs, indicating that there is demand for a full implementation of HTTP methods in HTML.

<p>
Below is a table of client side frameworks that use HTML as a network format, as well as their support for the various HTTP.

<table>
  <thead>
  <tr>
    <th>Framework</th>
    <th>HTTP Method Support</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <a href="https://htmx.org">
        htmx
      </a>
    </td>
    <td>
      <a href="https://htmx.org/docs/#ajax">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://unpoly.com/">
        Unpoly
      </a>
    </td>
    <td>
      <a href="https://unpoly.com/up.request#options.method">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://alpine-ajax.js.org/">
        Alpine-Ajax
      </a>
    </td>
    <td>
      <a href="https://alpine-ajax.js.org/examples/delete-row/">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://github.com/defunkt/jquery-pjax/">
        pjax
      </a>
    </td>
    <td>
      <a href="https://github.com/defunkt/jquery-pjax?tab=readme-ov-file#pjax-options">
        All HTTP Methods
      </a>
    </td>
  </tr>
  <tr>
    <td>
      <a href="https://turbo.hotwired.dev/">
        Hotwire Turbo
      </a>
    </td>
    <td>
      <a href="https://discuss.hotwired.dev/t/destroy-record-in-turbo-frame/2731">
        All HTTP Methods
      </a>
    </td>
  </tr>
  </tbody>
</table>

<h3>Usage of Non-GET &amp; Non-POST Methods</h3>

<p>
While the above table establishes the general support for the full gamut of HTTP methods, it does not establish the
usefulness of them for web developers.  In order to get a feel for that, we can search Github for use of the following
htmx attributes: <code>hx-put</code>, <code>hx-patch</code> &amp; <code>hx-delete</code>, which are used to issue
  the HTTP <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code> methods respectively.

<p>
Below is a table of the results of these searches:

<table>
  <thead>
  <tr>
    <th>Attribute</th>
    <th>Count</th>
    <th>% of <code>hx-get</code></th>
    <th>% of <code>hx-post</code></th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <code>hx-get</code>
    </td>
    <td>
      35.2k
    </td>
    <td>
      100%
    </td>
    <td>
      -
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-post</code>
    </td>
    <td>
      22.5k
    </td>
    <td>
      64%
    </td>
    <td>
      100%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-put</code>
    </td>
    <td>
      3.8k
    </td>
    <td>
      11%
    </td>
    <td>
      17%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-patch</code>
    </td>
    <td>
      1.2k
    </td>
    <td>
      3%
    </td>
    <td>
      5%
    </td>
  </tr>
  <tr>
    <td>
      <code>hx-delete</code>
    </td>
    <td>
      6.5k
    </td>
    <td>
      18%
    </td>
    <td>
      29%
    </td>
  </tr>
  </tbody>
</table>

<p>
You can see that there is widespread use of the three additional methods in htmx-based applications, particularly
<code>hx-put</code> and <code>hx-delete</code>.  It is worth noting the popularity of the <code>DELETE</code> method
in HTML-based web applications.  This is because it allows web developers to issue two different methods to the same
URL. A  web developer can use <code>POST</code> to <code>/reservations/</code> to create a new reservation and
a <code>POST</code> to <code>/reservations/123</code> to update an existing reservation (even if they would prefer to
issue a <code>PUT</code> or <code>PATCH</code>) but must create a separate end-point (or use another workaround) to
delete that reservation.

<p>
With the addition of the <code>DELETE</code> method, web developers can follow the natural, resource-oriented URL
pattern.

<h2>Common Patterns</h2>

<h3>Logout</h3>

<p>
One common web application pattern that is not well-supported in HTML due to the lack of
additional HTTP methods beyond GET and POST is a logout flow.
It is common in many web applications to have some sort of login functionality, creating a session for a user where their identity is established for future requests.

Once a user has logged in, web applications typically allow users to then choose to log out of the web application.
This is typically done in one of two ways:

<ul>
  <li>
    The user clicks a link that issues a <code>GET</code> to a path (e.g. <code>/session</code>) to log them out.
  </li>
  <li>
    The user clicks a button in a form that issues a <code>POST</code> to a path (e.g. <code>/session</code>) to log them out.
  </li>
</ul>

Neither of these solutions is ideal, however:

<ul>
  <li>
    The link-based GET causes a mutation of server state (it deletes the session).
    This is in conflict with the intended semantics of GET and can interact poorly with other features of the web platform such as prefetch.<f-note>
      Not only did prefetch cause issues with a number of existing websites <a href=https://stackoverflow.com/a/14587231/15456438>when it was first introduced</a>,
      it remains a <a href="https://georgemauer.net/2024/08/01/a-heck-of-a-wild-bug-chase.html">live source of bugs </a>even today.
      </f-note>
  </li>
  <li>
    The form-based POST is more idiomatic, but the logout operation is idempotent and should be safely retryable, whereas a POST request is not.
  </li>
</ul>

Of the two, the POST option is clearly better, but developers nevertheless often use GET because HTML doesn't provide a natural way to describe ending or deleting a resource.<f-note>
This pattern is so common it was officially supported and <a href="https://docs.djangoproject.com/en/5.0/releases/4.1/#log-out-via-get">only recently deprecated </a>by Django.
</f-note>
Left with the need to invent their own semantics, developers frequently choose what's simplest (which is a link).<f-note>
That you cannot delete a resource with HTML is the primary semantic problem here, but there is a second one: it feels strange to wrap an action like "logout" in a form when you're clearly not submitting a form.
Writing it as a link feels much more direct.
We address this limitation in <a href="#">Triptych Proposal #2: Button HTTP Requests</a>.
</f-note>

<p>
The ideal request for this common piece of functionality would be one that is known to be mutative, known to be idempotent, and accurately describes the action being taken.
If HTML were able to issue a <code>DELETE</code> to <code>/session</code> it would these needs in a way that it currently cannot, making implementing this extremely common functionality less error-prone and more natural.

<h3>Application Server Permissions</h3>

<p>
The most popular web frameworks all support the ability to declare handlers for HTTP route and method combos.
Access to additional methods dramatically simplifies route declaration and remove the potential for footguns.

<p>
In this example, we'll be using ExpressJS (a popular JavaScript server), and re-using the hotel reservation concept from <section-ref ref=sample-usage>Section 3</section-ref> to show what a server implementation could look like.<f-note>
We use ExpressJS because it has an especially nice declarative interface for middleware, but the basic concepts can be easily translated to other frameworks like Flask (Python), Spring (Java) and Rails (Ruby).
</f-note>

<pre class="code">
router.post(   '/reservation',                   requireLogin,     createReservation)
router.get(    '/reservation/:reservationId',    requireOwnership, getReservation)
router.post(   '/reservation/:reservationId',    requireOwnership, updateReservation)
</pre>

<p>
Even if you are unfamiliar with ExpressJS, it is relatively easy to understand what is going on here.
ExpressJS lets you declare a method, a route, and then a series of functions that handle the request.
To make a reservation, the client issues a POST request to <code>/reservation</code>, then runs the <code>requireLogin</code> function, and if that succeeds, runs the <code>createReservation</code> function.<f-note>
The indentation servers no purpose other than readability.
</f-note>
Viewing and updating a reservation requires it to be <em>your</em> reservation, checked by the <code>requireOwnership</code> method.

<p>
How then, should we implement the ability to delete a reservation?
Without access to additional HTML methods in the form, we have two choices.
We can double-up on a handler:

<pre class="code">
// Note the new updateOrDeleteReservation method
router.post(   '/reservation',                   requireLogin,     createReservation)
router.get(    '/reservation/:reservationId',    requireOwnership, getReservation)
router.post(   '/reservation/:reservationId',    requireOwnership, updateOrDeleteReservation)
</pre>

<p>
No longer does the router, and therefore the network layer, have a complete view of the application's functionality, because deletes and updates happen within the same function.
If <code>POST /reservations/:reservationId</code> starts throwing internal server errors, it won't be immediately obvious what functionality is impacted.

<p>
Also, deletes and updates might have different permissions associated with them!
What if you want to implement group reservations, and give everyone in the group permission to edit the reservation, but only the owner permission to delete it?
The safest, simplest, and most secure way would be to have separate routes with separate permission functions, but since we're re-using one function for two actions, we don't have access to that.
To accomplish that, we have to mess with the URI:

<pre class="code">
router.post(   '/reservation',                        requireLogin,             createReservation)
router.get(    '/reservation/:reservationId',         requireGroupMembership,   getReservation)
router.post(   '/reservation/:reservationId',         requireGroupMembership,   updateReservation)
router.post(   '/reservation/:reservationId/delete',  requireOwnership,         deleteReservation)
</pre>

<p>
Now we have the ability to declare separate permissions, but we've lost the essential semantic that the URI represents a resource.
This get messy fast.
What if reservations have sub-resources, like members?
It's easy to model that for getting and updating the reservation, because you just add <code>/members</code> to the URI.
But now we have two confusing cases—one where the sub-resource after the reservation represents a new thing, and one where it represents an action on the main resource.
This does not scale.

<p>
The ideal situation is obvious, from the server's standpoint:

<pre class="code">
router.post(   '/reservation',                        requireLogin,             createReservation)
router.get(    '/reservation/:reservationId',         requireGroupMembership,   getReservation)
router.put(    '/reservation/:reservationId',         requireGroupMembership,   updateReservation)
router.delete( '/reservation/:reservationId',         requireOwnership,         deleteReservation)
</pre>

<p>
Each action has a distinct method, permission, and handler.
The client has access to idempotency semantics now, so the client knows that it's safe to retry the PUT and DELETE requests.
The network layers can log and track each of the actions at an appropriate level of granularity.
And most importantly, the purpose of the server is clear and legible to present and future maintainers.

<h2>Alternatives and Additions</h2>

<h3 id=custom-method>Custom Method Attribute</h3>

<p>
In addition to adding PUT, PATCH, and DELETE support to the <code>method</code> attribute, it makes a lot of sense to add another attribute, <code>custommethod</code>, that overrides the value in <code>method</code>:

<pre class="code">
&lt;form action="/reservations/123" method="POST" custommethod="PUT"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>

<p>
In this example, browsers that support PUT and <code>custommethod</code> would issue a PUT request to the specified action, while browsers that do not support those features would issue a POST request (servers would have to support both methods, of course).
This solves the problem where existing browsers that do not recognize the value in <code>method</code> will fallback to a GET request, by allowing <code>method</code> to serve as a "best supported method" fallback, while <code>custommethod</code> explicitly denotes experimental behavior.<f-note>
If the author intended to send form data as body content, this has the regrettable side-effect of exposing that form data to the URL in the form of query parameters.
This could cause information leakage—URLs are visible in plaintext in various context where request content is not.
As long as browser support for the new methods remains a live concern, the possibility of information leakage will hinder adoption in sensitive contexts.
<br><br>
Thanks to <a href="https://github.com/whatwg/html/issues/3577#issuecomment-2303573521">@jlunman</a> for asking us to address this issue.
</f-note>

<p>
Another major advantage of the <code>custommethod</code> attribute is that it allows for a more robust polyfill mechanism.
The existing <a href="https://github.com/alexpetros/triptych">Triptych polyfill</a> has the crucial caveat that client-side JavaScript cannot modify navigation in the manner necessary to create the robust experience proposed here.
The addition of a bridge attribute enables a better, navigation-only polyfill, from the <em>server</em> side:

<pre class="code">
&lt;form action="/reservations/123" method="POST" custommethod="PUT"&gt;
  &lt;input type="hidden" name="_method" value="PUT"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>

<p>
While a bit clunky visually, this form builds on the existing method workarounds to create a smooth upgrade path.
Servers that recognize the <section-ref ref="hidden-input-hack">hidden input hack</section-ref> can handle matching POST and PUT requests with the same handler function. That one handler can return a 303 "See Other" redirect for both cases, which achieves the same thing regardless of whether the browser sent a POST or a PUT request.
As browser support picks up and the need for a fallback diminishes, the hidden input and override can be removed in favor of a single <code>method=PUT</code>.

<p>
We chose <code>custommethod</code> as the attribute name in anticipating that it will one day be used for proper custom HTTP method support, of the kind anticipated in <a href="https://www.w3.org/TR/form-http-extensions/#introduction">this working group note.</a>
Eventually, it can be used for entirely arbitrary HTTP methods, while <code>method</code> is reserved for officially supported ones.
In this manner, the upgrade/fallback mechanism proposed here can be re-used for future additions to HTTP's methods.

<h3>Omit PATCH</h3>
<p>
PUT and DELETE are necessary to include a full CRUD grammar in HTML; PATCH is not.

<p>
If you are going to do the work to generalize the <code>&lt;form&gt;</code> method attribute anyway, it doesn't seem like there's huge benefit to omitting PATCH. Nevertheless, the proposal could mostly succeed in its goals without PATCH, since most RESTful design practices focus on PUT and DELETE.

<h3>Allow for DELETE request bodies</h3>
<p>
There's no inherent reason why a DELETE request couldn't send body content, and many popular frameworks, like ExpressJS, do support it.
Nor is DELETE content expressly prohibited by the spec, which allows for such requests if the origin server has indicated that it supports them.
Since most HTML forms are same-origin, it could make sense to allow the form to indicate that it would be fine with DELETE content.

<p>
A <code>usebody</code> attribute could be included to indicate support.
If present, the form would send its data as part of the body, for DELETE (or GET) requests;
it would be ignored for all other methods.

<h2 id=history>Update History</h2>

<dl>
  <dt> <time datetime="2024-09-04">Sept 4, 2024</time></dt>
  <dd>
    <ul>
      <li>Changed <code>overridemethod</code> to <code>custommethod</code>
      <li>Added note about handling non-redirection codes identically
    </ul>
  </dd>
  <dt> <time datetime="2024-08-29">Aug 29, 2024</time></dt>
  <dd>
    <ul>
      <li>Attended <a href="https://github.com/whatwg/html/issues/10574#issuecomment-2318560972">WHATNOT meeting</a> and received feedback on proposal.
    </ul>
  </dd>
  <dt> <time datetime="2024-08-26">Aug 26, 2024</time></dt>
  <dd>
    <ul>
      <li>Added "Override Method and Server-Side Polyfill" section
    </ul>
  </dd>
</dl>


<section class=footnotes>
<h2>Footnotes</h2>
<footnote-list></footnote-list>
</section>
